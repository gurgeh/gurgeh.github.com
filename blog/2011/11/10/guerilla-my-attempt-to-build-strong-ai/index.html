
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Guerilla - my attempt to build a strong AI - IFHO</title>
  <meta name="author" content="David Fendrich">

  
  <meta name="description" content="Having given the topic of artificial general intelligence (or AGI) a fair amount of thought over the last decade, a plausible path forward, based on &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fendrich.se/blog/2011/11/10/guerilla-my-attempt-to-build-strong-ai/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="IFHO" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


  

</head>


<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  <!--  <div id="logoLeft">{</div><div id="logText"><img src="/images/SimpsonDavid.png" width="36" height="36"></div><div id="logoRight">}</div>
  	<div class="clear"></div>-->
  </div>
  <h1><a href="/">IFHO</a></h1>
  
    <h2>In Fendrich's Humble Opinion</h2>
  
  <div class="clear"></div>
</hgroup>


</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fendrich.se" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Guerilla - My Attempt to Build a Strong AI</h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-11-10T00:00:00+01:00" pubdate data-updated="true">Nov 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><div class='post'>
Having given the topic of artificial general intelligence (or AGI) a fair amount of thought over the last decade, a plausible path forward, based on something like an encyclopedia for algorithms, has slowly congealed in my head. I need to write it down before I start coding. Preferably in the form of a blog post, to get feedback. This is that post.<br /><br /><span class="Apple-style-span" style="font-size: large;">Background</span><br /><br />When I write about strong AI or AGI, I mean an algorithm with general problem solving skills. Not necessarily a mind inhabiting a robot, running around talking to people and passing the Turing test (though eventually a successful AGI could be taken in that direction), but rather something that can be applied to a wide variety of problems. For example: playing chess and poker, picking stocks, solving puzzles, proving math theorems, analyzing and writing computer code, speech and image recognition, improve itself by learning and self modification, etc.<br /><br /><br />There is an alluring approach to AGI, where you begin with a &#8220;simple&#8221; seed program, which will learn and self improve and eventually evolve to human intelligence and beyond. I think that in practice, the problem is that it has taken lots of people lots of time to invent all those algorithms that can be useful in general problem solving.&nbsp;Humans are pretty good at general problem solving - certainly much better than the best software/hardware combination we have today. Constructing algorithms to solve specific problems is in itself a kind of problem solving, and we humans have certainly invented many different algorithms for a wide variety of purposes. One might suspect that&nbsp;the computational depth of inventing/discovering algorithms is very large.&nbsp;So unless the seed program is actually very advanced, more like a full grown Sequoia than a seed, it might take too much time for it to invent all those algorithms and heuristics that we, as a civilization, already have.<br /><br /><br />Topics that are potentially useful to understand include:<br /><br /><br /><ul><li>Statistics (Bayes rule, distributions, Markov chains, running an experiment, etc).</li><li>Algorithms for optimizing parameters (genetic algorithms, simulated annealing, steepest descent, linear programming, random testing and purely analytical methods). In some situations it could take days or more to try a single parameter configuration. In other situations evaluating the fitness of a parameter configuration is just a couple of CPU instructions. Approaching these different tasks require a variety of methods</li><li>Logic</li><li>Basic mathematics (calculus, algebra, geometry, etc)</li><li>Code analysis (lambda calculus, etc)</li><li>Formal proof methods (knowledge of the methods listed here: http://en.wikipedia.org/wiki/Mathematical_proof) and formal reasoning</li><li>Tree and graph searching (depth-first, breadth-first, A*, beam, minimax, alpha-beta, Dijkstra)</li><li>Bayesian belief networks</li><li>Pattern recognition</li><li>Compression</li><li>Monte Carlo method</li><li>Clustering and classification</li><li>Fourier transforms, wavelets</li><li>Function approximation (analytical or with neural networks or genetic programming)</li><li>Inverting functions (in other words, given a program function and its output tell me what the input was - this turn out to be a very general way of posing questions)</li></ul><br /><div>&#8230;and of course many more.</div><div><br /></div><div>I consider statistics and parameter optimization to be the most important areas for intelligence, since you need them to learn. Pattern recognition (perhaps implemented with statistics and optimization) and various forms of tree searching are also vital.</div><br /><span class="Apple-style-span" style="font-size: large;">An encyclopedia of algorithms</span><br /><br />My approach is based on implementing an encyclopedia of useful algorithms that:<br /><br /><ol><li>Know to which tasks they can be applied</li><li>Can give a rough, initially often ridiculously rough, estimate of what the probability is that they solve the task after a certain time or, in the case of an open-ended task such as optimization, can give a rough estimate of how well the task is solved after a certain time.</li><li>Can continuously update the estimate as the task is solved</li></ol><br />It is important to stress that it is not enough to just implement a library of algorithms that can work on the same datastructures. The important thing is that you need metadata, describing when an algorithm can be used and the algorithmic complexity in time and memory. With time, you want to automatically build up more knowledge of the algorithms, gradually improving the time and success estimations as well as improving your knowledge of which algorithms are suitable in which situations.<br /><br />The algorithms should be broken up into as many natural subtasks as possible, so that when new algorithms are added to the system, they can try to solve these subtasks as well, thus creating new hybrid algorithms.<br /><br />A <i>task</i> is basically a function call together with its arguments. An algorithm that can solve a task implements the corresponding function and a time/success estimator. Similarly to function overloading in C++, the function header might state specializations, additional properties, of the function arguments that must be true for the algorithm to be a contender to solve it. It is important that the <i>Scheduler</i> (see below) immediately knows which algorithms are suitable for a certain task, so the mentioned &#8220;additional argument properties&#8221; must be immediately available. If a certain property requires work to find out - &#8220;is the list in the first argument sorted?&#8221; - and an algorithm still needs it, a new algorithm can be constructed that first checks if the list is sorted and then either fails or asks the task again with the new property set. This new algorithm would have higher estimates of running time and lower estimates of success than the original algorithm.<br /><br /><span class="Apple-style-span" style="font-size: large;">The Scheduler</span><br /><br />When a task is added to the task pool it always has a <i>price</i> attached to it. The Scheduler runs those algorithms that currently promise best expected price per time unit. Algorithms that need subtasks solved has to assign a price to those too, before adding them to the task pool. That price should reasonably reflect how much of the overall time the subtask is expected to take. If it turns out that a subtask consistently take a smaller or larger fraction of the estimated total time, there should be algorithms that modify the price for these subtasks and correspondingly the total time estimate (also, see <i>Self Improvement</i> below).<br /><br />Open-ended tasks where something should be optimized cannot have just one value attached to them. Instead they need to have a function from achieved performance to price, or at least a rough mapping from some performance values to price. This mapping stops the system from optimizing for too long on a relatively unimportant subsubsubtask somewhere.<br /><br />Algorithms that can either fail or succeed on a task need a similar mapping, where they give probability of success as a function of time.<br /><br />One can also imagine that the algorithms could give a confidence interval or standard deviation on their estimates to tell the Scheduler how sure they are of their estimates, but I am not quite sure how this should be used, so for now they won&#8217;t.<br /><br />For my first try, the Scheduler will use a simple heuristic. The algorithm that claims to have the best price / time ratio for any task currently in the task pool will get to run it. For one thread this will be optimal in some sense. It gets more complex when you have many algorithms running in parallel on multiple cores or even clusters. For example, you want to slightly punish two algorithms trying to complete the same task in parallel, since the first one to succeed will always make the other algorithms work moot. On the other hand sometimes it makes sense to attack an important problem from several angles, so you don&#8217;t want to forbid it entirely either.<br /><br />In a later design, the Scheduler should be able to use the task pool to think about how it should Schedule. Obviously this must not end in an infinite Scheduling loop or general inefficiency, since normally the Scheduler must work very quickly.<br /><br />The Scheduler&#8217;s work and indeed that of the whole system will not be especially interesting when there are only a few algorithms implemented. The first interesting moment will be when new hybrid algorithms emerge, where subtasks are sometimes handled by unanticipated algorithms. I am not sure how many algorithms needs to be implemented for the system to show interesting emergent behaviour. Probably more than ten, but less than a hundred, depending, of course, on which algorithms and what you count as an individual algorithm.<br /><br /><span class="Apple-style-span" style="font-size: large;">Self improvement</span><br /><br />From the above, you can see that the system will not be self improving at first. However, by adding self improvement tasks, it will start doing things like improving the time estimates of the algorithms, learn to what degree one algorithm&#8217;s failure to solve a task should also reflect on the estimates of other algorithms, learn which situations are suitable for which algorithms; for example which algorithms perform well on the subtasks posted from a certain algorithm. It can also have an algorithm that constructs new lower-priced training tasks from real tasks, for example generalizations or specializations of a problem, just out of &#8220;curiosity&#8221;.<br /><br />Producing new/improved code and algorithms, either for self improvement or as the solution for a puzzle or some other task, is among the most advanced tasks the system can try. It will not be able to do much of interest in this area until it is really strong, but it could start out by trying simple modifications of existing algorithms or trying them on similar tasks, a bit like in genetic programming.<br /><br />The system is also inherently self improving from a sort of network effect, since for each algorithm added, the existing algorithms get potentially better.<br /><br /><span class="Apple-style-span" style="font-size: large;">What now?</span><br /><br />When I have implemented the base system, I will start by applying the AGI to function inversion. Trivial stuff at first, of course, but I hope to eventually make it solve real puzzles like Towers of Hanoi by a combination of searching and deduction. Also, it would be fun to try some games and an NP-complete problem like 3-SAT.<br /><i><br /></i><br />It would be beautiful if the algorithms were written in the same simplified, purely functional (thus easier to analyze), LISP that I plan to write the problem definitions in. Alas, good AI needs to be fast and a 100x slower system just because the algorithms run in my own immature poorly interpreted language instead of C is not so fun. However, a good JIT compiler is a very good test for an AGI. You continuously have to weigh optimization time against running what you have. If the AGI in some distant future JITs its own code, effectively running and optimizing itself, I will consider the entire project a grand success :).<br /><br />I forget why I called the project Guerilla. It was probably terribly clever. Nevertheless, here is the link to the Github repository:&nbsp;<a href="https://github.com/gurgeh/Guerilla">https://github.com/gurgeh/Guerilla</a>. It does not contain much yet.<br />  <div class="zemanta-pixie" style="height: 15px; margin-top: 10px;"></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>sm4096</div>
<div class='content'>
Ai building efforts start at definitions:  Ai that can<br />specify goals and weight them , acquire combine breakdown and refine strategy.<br /><br />A strategy specifies goals, their desirability and at what likelihoods to take what actions on what (set of) conditions. <br /><br />Devising strategies can be broken down into:<br />creating and assessing conditions for actions,<br />weight of goals, estimates of cost for actions,<br />estimates of effectiveness of actions, finding related strategies,<br />taking strategies apart,<br />combining strategies,<br />covering contingencies,<br />evaluating strategies</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
I would be interested to see the input from which this AI (when implemented) would be able to learn how to play the 5-in-a-row game.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
This comment has been removed by the author.</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@acetoline No, the project is not abandoned, but thanks for asking :). I tend to post infrequent, overambitiously long posts, so a few weeks silence is normal.<br /><br />The reason the github activity is low is more silly. I am currently in something between the design and implementation stage, writing Python code with a few pseudocode elements and a lot of prose. For some reason, I have not considered this semi-code &quot;commit-worthy&quot;.<br /><br />I promise a github update this week.</div>
</div>
<div class='comment'>
<div class='author'>acetoline</div>
<div class='content'>
Hi, I noticed there hasn&#39;t been any activity on your blog or github lately. I hope you haven&#39;t abandoned the project.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Doesn&#39;t sound like a well scalable solution. Don&#39;t get overexcited/misled after some early luck in well defined toy worlds. With teaching by manual algorithm entry by techies, you aren&#39;t gonna get very far.</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
Hopefully, yes, it should be able to solve general problems using more specialized algorithms working together. It will not, however, take a set of specialized algorithms (let&#39;s say playing chess, checkers, poker and backgammon) and produce a general game playing algorithm. That is not how it achieves generality.<br /><br />It is geared towards very technical users. It takes input tasks as snippets of code and gives a  set of inputs that makes the function output true. This is called function inversion and is a fairly simple way of describing puzzles and technical problems.<br /><br />If it turns out to be a useful system for solving these types of tasks (a big IF - no one has really been able to achieve that). It would be a very good base on which to build something that can communicate with non-technical users and interact with our fuzzy world. That is not it&#39;s primary purpose, though.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Can this &#39;AGI&#39; generate general algorithms from a set of relevant non-general algorithms? Will non-technical users be able to teach this AI by describing specific (/non-general) scenarios?</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@Jiri Swedes, Norwegians, Danes and many Finns can read Swedish. That makes up a good 0.3% of the earth population :).<br /><br />Actually, I will remove that. That source code is not for human consumption yet. It is just test cases for analyzing source code, written in an odd Lisp dialect. No actual code relating to implementing either any of the algorithms I write about or the Scheduler.</div>
</div>
<div class='comment'>
<div class='author'>Mentifex</div>
<div class='content'>
One way to build a strong AI is outlined in the <a href="http://mind.sourceforge.net/aisteps.html" rel="nofollow">http://mind.sourceforge.net/aisteps.html</a> and develops into a simple but gradually <a href="http://www.scn.org/~mentifex/AiMind.html" rel="nofollow">expandable AI Mind</a>.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Don&#39;t use Swedish in the source, man! &#39;Nobody&#39; can read that ;-)</div>
</div>
</div>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">David Fendrich</span></span>

      








  


<time datetime="2011-11-10T00:00:00+01:00" pubdate data-updated="true">Nov 10<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/agi/'>AGI</a>, <a class='category' href='/blog/categories/ai/'>AI</a>, <a class='category' href='/blog/categories/guerilla/'>Guerilla</a>, <a class='category' href='/blog/categories/encyclopedia/'>encyclopedia</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://fendrich.se/blog/2011/11/10/guerilla-my-attempt-to-build-strong-ai/" data-via="fnedrik" data-counturl="http://fendrich.se/blog/2011/11/10/guerilla-my-attempt-to-build-strong-ai/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left articlenav" href="/blog/2010/12/28/compression-prediction-and-artificial/" title="Previous Post: Compression, prediction and artificial intelligence">&laquo; Compression, prediction and artificial intelligence</a>
      
      
        <a class="basic-alignment right articlenav" href="/blog/2012/09/27/octopress-and-github-as-blogging-platform/" title="Next Post: Octopress and Github as a blogging platform">Octopress and Github as a blogging platform &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/">A better algorithm for backups and rolling logs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/">Pre-programming Mental Silence Meditation with Entrainment</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/">Compile time loops in C++11 with trampolines and exponential recursion</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/31/c-plus-plus-11-and-boost-succinct-like-python/">C++11 and Boost - succinct like Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/28/no/">No, really. Use Zsh.</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/gurgeh">@gurgeh</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'gurgeh',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating...</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("fnedrik", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/fnedrik" class="twitter-follow-button" data-show-count="false">Follow @fnedrik</a>
  
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - David Fendrich -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




<a title="Real Time Analytics" href="http://getclicky.com/100529738"><img alt="Real Time Analytics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(100529738); }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100529738ns.gif" /></p></noscript>


</body>
</html>
