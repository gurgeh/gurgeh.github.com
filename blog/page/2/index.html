
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>IFHO</title>
  <meta name="author" content="David Fendrich">

  
  <meta name="description" content="Around the world a few people and companies are working towards the goal of strong AI&nbsp;or artificial general intelligence, which is more or less &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fendrich.se/blog/page/2/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="IFHO" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


  

</head>


<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  <!--  <div id="logoLeft">{</div><div id="logText"><img src="/images/SimpsonDavid.png" width="36" height="36"></div><div id="logoRight">}</div>
  	<div class="clear"></div>-->
  </div>
  <h1><a href="/">IFHO</a></h1>
  
    <h2>In Fendrich's Humble Opinion</h2>
  
  <div class="clear"></div>
</hgroup>


</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fendrich.se" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2010/06/16/digital-immortality-true-ai-and/">Digital Immortality, True AI and the Destruction of Mankind</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2010-06-16T00:00:00+02:00" pubdate data-updated="true">Jun 16<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Around the world a few people and companies are working towards the goal of <a href="http://en.wikipedia.org/wiki/Artificial_general_intelligence">strong AI</a>&nbsp;or artificial general intelligence, which is more or less the same thing. Too few, if you ask me.<br /><br />Today I was reminded of a strategy towards AGI that I have sometimes dreamed of. It is not the strategy I believe most in, but I think it is interesting nonetheless.<br /><br />What if you (assuming you are a competent programmer), from now on, tried to automate as many of your computer tasks as possible. Instead of doing something, try making the computer do it. Even if it takes you ten or a hundred times as long, your time investment will hopefully pay dividends in the future. Starting out, many things will be out of reach, but you will slowly build a knowledge base and an algorithm base that can mimic your preferences and skills. this will enable you to take on harder tasks and so on. You are building a digital assistant from the ground up.<br /><br />Maybe this undertaking is too ambitious for one person, especially if they actually wanted to get something done besides building a digital assistant. In that case, my proposal stands, but instead use a small team (Google and Microsoft, I know you have a few talented guys to spare for a grand project) that tries to automate the computer tasks of one guy.<br /><br />Take email, for example. Propose automatic actions on incoming mail, including replies, forwards and adding stuff to the calendar. Initially, very few emails will be understandable, but gradually I expect the algorithm to get better at parsing language and to get a better model of the user and the world. Perhaps one part of the knowledge base is building a <a href="http://en.wikipedia.org/wiki/Bayesian_network">Bayesian network</a>&nbsp;that models the user&#8217;s preferences. The important thing is: solve the emails one at a time, using as general rules as you can get away with, but as specialized rules as you practically have to.<br /><br />Want to look something up on Wikipedia? Make travel plans online? Make a purchasing decision? Solve it in code, as general as you can. When the AI is further advanced, you start to write documents and code collaboratively, and so forth. One way of developing the AI is to let it observe your digital life and all your actions. Ultimately, what you end up with is a digital model of yourself, that gets more and more like the original. It answers mail, reads news and maybe comments on it in tweets and blogs. In effect, you achieve digital immortality.<br /><br />Obviously, the weakness here is that I have not proposed what algorithms should be used for this digital alter ego. I do, however, feel that the task of general AI will benefit from both clever general algorithms and clever specialized algorithms and specialized knowledge. An organic hodge-podge of hacks and patches, very much like the brain itself.<br /><br />When a mathematician approaches the problem of AGI, they want a clean solution. One algorithm to bind them all, like the <a href="http://www.idsia.ch/~juergen/goedelmachine.html">Gödel Machine</a>&nbsp;of&nbsp;<a href="http://www.idsia.ch/~juergen/">Jürgen Schmidhuber</a>&nbsp;and <a href="http://www.hutter1.net/">Marcus Hutter</a>. When engineers approach the same problem, they tend to engineer grand designs, like <a href="http://en.wikipedia.org/wiki/Ben_Goertzel">Ben Goertzel</a>&#8217;s <a href="http://novamente.net/">Novamente</a>&nbsp;and <a href="http://www.opencog.org/wiki/The_Open_Cognition_Project">OpenCog</a>. I can certainly see the charm of both approaches and I hope that they succeed, but maybe the most practical way forward is just to tackle one small real-world task at a time - the &#8220;guided hodge-podge&#8221; approach.<br /><br />About the destruction of mankind? No, I don&#8217;t think we will have any of that, but some smart people do. Like Michael Anissimov: <a href="http://www.acceleratingfuture.com/michael/blog/2007/04/why-is-ai-dangerous/">&#8220;Why is AI dangerous?&#8221;</a>. Still, a title is better when it involves destruction, don&#8217;t you think?</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Michael Anissimov</div>
<div class='content'>
Why don&#39;t you think there&#39;s a risk from AI destroying us?  Just context-insensitive optimism, or what?  I suggest you check out Stephen Omohundro&#39;s paper, &quot;Basic AI Drives&quot;, and also Eliezer Yudkowsky&#39;s &quot;AI as a Positive and Negative Factor in Global Risk.</div>
</div>
<div class='comment'>
<div class='author'>Harley Mellifont</div>
<div class='content'>
The problem with most strong AI advocates like yourself is that you think that all it takes to be intelligent is to behave intelligently. This is false. In psychology, can you truly determine someones intent from their behaviour alone? Take Steven Hawking for example, he can communicate only through technology. If he didn&#39;t have that technology, he would still be highly intelligent, but not according to you since he can&#39;t behave intelligently. There is far more to intelligence than behaviour: understanding is what needs to be modelled.<br /><br />I suggest you read the book On Intelligence by Jeff Hawkins.</div>
</div>
<div class='comment'>
<div class='author'>Guili</div>
<div class='content'>
&quot;solve the emails one at a time, using as general rules as you can get away with, but as specialized rules as you practically have to&quot;.<br />From what I learned doing my PhD in NLP, the more emails you &quot;solve&quot; (i.e. parse the syntax, disambiguate the 67 possible solutions, analyze the sense of each word in its context, combine these senses, disambiguate the 670 possible interpretations), the more your general rules/ specific rules ratio will decrease. <br />I can&#39;t prove this, but it&#39;s based on my observation of several rule-based systems in NLP.</div>
</div>
<div class='comment'>
<div class='author'>Ian Ozsvald</div>
<div class='content'>
I&#39;m a part of one of those companies that&#39;s working on an AGI - the project is RIA (http://www.qtara.com/) and the beta looks just like the website. It can help you write email, use Skype, research, read the news - all via a natural language spoken interface.<br /><br />An open source equivalent by the very smart John is: http://code.google.com/p/open-allure-ds/<br /><br />I&#39;m building up a set of like-minded folk for the A.I.Cookbook, mostly using Python to solve useful problems. Some of the active projects are documented here: http://blog.aicookbook.com/ with a budding discussion group: http://groups.google.com/group/aicookbook<br /><br />Cheers,<br />Ian.</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2010/05/05/solving-sudoku-with-genetic-algorithms/">Solving Sudoku With Genetic Algorithms</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2010-05-05T00:00:00+02:00" pubdate data-updated="true">May 5<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
I recently wrote a small Python library for <a href="http://en.wikipedia.org/wiki/Genetic_algorithm">genetic algorithms</a> (GA), called <a href="http://code.google.com/p/optopus">optopus</a>. One thing I tried when I played around with it was to solve a <a href="http://en.wikipedia.org/wiki/Sudoku">Sudoku</a> puzzle. There are plenty of efficient ways to solve Sudoku, but with my shiny new hammer, all problems look like nails.<br /><br />Also, I remember that I once read something from someone who tried a GA C-library on Sudoku and concluded that it was not a suitable problem. If I could solve it with my slick library, that random person on the internet, whose web page I might never find again but who may exist as far as you know, would certainly be proven wrong. A worthy cause.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Genetic algorithms</span><br />A genetic algorithm is a general way to solve optimization problems. The basic algorithm is very simple:<br /><ol><li>Create a population (vector) of random solutions (represented in a problem specific way, but often a vector of floats or ints)</li><li>Pick a few solutions and sort them according to fitness</li><li>Replace the worst solution with a new solution, which is either&nbsp;a copy of the best solution, a mutation (perturbation) of the best&nbsp;solution, an entirely new randomized solution or a cross between the two&nbsp;best solutions. These are the most common evolutionary operators, but you could dream up others that use information from existing solutions to create new potentially good solutions.</li><li>Check if you have a new global best fitness, if so, store the solution.</li><li>If too many iterations go by without improvement, the entire population&nbsp;might be stuck in a local minimum (at the bottom of a local valley, with a possible chasm&nbsp;somewhere else, so to speak). If so, kill everyone and start over at 1.</li><li>Go to 2.</li></ol>Fitness is a measure of how good a solution is, lower meaning better. This measure is performed by a fitness function that you supply. Writing a fitness function is how you describe the problem to the GA. The magnitude of the fitness values returned does not matter (in sane implementations), only how they compare to each other.<br /><br />There are other, subtly different, ways to perform the evolutionary process. Some are good and some are popular but bad. The one described above is called tournament selection and it is one of the good ways. Much can be said about the intricacies of GA but it will have to be said somewhere else, lest I digress completely.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Optopus and Sudoku</span><br />Using optopus is easy:<br /><br /><pre class="brush: python">from optopus import ga, stdgenomes<br /><br />#Now we choose a representation. We know that the answer to the puzzle must be some permutation of the digits 1 to 9, each used nine times.<br /><br />init_vect = sum([range(1,10)] * 9, []) # A vector of 81 elements<br />genome = stdgenomes.PermutateGenome (init_vect)<br /><br />#I made a few functions to calculate how many conflicts a potential Sudoku solution has. I'll show them later, but for now let us just import the package. I also found a puzzle somewhere and put it in the PUZZLE constant.<br /><br />import sudoku<br />solver = ga.GA(sudoku.ga_sudoku(sudoku.PUZZLE) , genome)<br /><br />#And now, when we have supplied the GA with a fitness function (ga_sudoku, which counts Sudoku conflicts) and a representation (genome), let us just let the solver do its magic.<br /><br />solver.evolve(target_fitness=0)<br /></pre><br />And in a few minutes (about 2.6 million iterations when I tried) the correct answer pops out!<br /><br />The nice thing about this method is that you do not have to know anything about how to solve a Sudoku puzzle or even think very hard at all. Note that I did not even bother to just let it search for the unknown values - it also has to find the digits that we already know (which should not be too hard with a decent fitness function, see below). The only bit of thinking we did was to understand that a Sudoku solution has to be a permutation of&nbsp;<i>[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9]</i>, but this merely made the evolution part faster. If we wanted to make it faster still, we could make a genome type that let us say that there are actually nine separate vectors who are each guaranteed to be a permutation of 1 to 9. We could have thought even less and represented the solution by 81 ints who are all in the range 1 to 9, by using another genome type:<br /><br /><span class="Apple-style-span" style="font-size: small;"><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&gt;&gt; genome = stdgenomes.EnumGenome(81, range(1,10))</span></span><br /><br />The range argument to EnumGenome does not have to be a vector of integers, it could be a vector of any objects, since they are never treated like numbers.<br /><br />In my experiment this took maybe 15 - 30 minutes to solve. For more difficult Sudoku puzzles, I would definitely go with the permutation genome, since using EnumGenome increases the search space to 9^81 or <i>196627050475552913618075908526912116283103450944214766927315415537966391196809</i> possible solutions.<br /><br />FYI, this is the puzzle in sudoku.PUZZLE:<br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&nbsp;&nbsp;4|8 &nbsp;| 17</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>67 |9 &nbsp;| &nbsp;&nbsp;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>5 8| 3 | &nbsp;4</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&#8212;&#8212;&#8212;&#8211;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>3 &nbsp;|74 |1 &nbsp;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&nbsp;69| &nbsp; |78&nbsp;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&nbsp;&nbsp;1| 69| &nbsp;5</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&#8212;&#8212;&#8212;&#8211;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>1 &nbsp;| 8 |3 6</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>&nbsp;&nbsp; | &nbsp;6| 91</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>24 | &nbsp;1|5 &nbsp;</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">I think a Sudoku puzzle that is harder for humans would not be that much harder for optopus to solve, but I have not tested it.</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;"><span class="Apple-style-span" style="font-size: x-large;">Sudoku fitness function</span></span><br /><span class="Apple-style-span" style="font-family: inherit;">OK, so that was a ridiculously easy way to solve a Sudoku puzzle, but I skipped one part that is crucial to all GA - describing the problem using a fitness function. I had to do the following:</span><br /><br /><pre class="brush: python">DIM = 9<br /><br />def one_box(solution, i):<br />    """Extract the 9 elements of a 3 x 3 box in a 9 x 9 Sudoku solution."""<br />    return solution[i:i+3] + solution[i+9:i+12] + solution[i+18:i+21]<br /><br />def boxes(solution):<br />    """Divide a flat vector into vectors with 9 elements, representing 3 x 3<br />    boxes in the corresponding 9 x 9 2D vector. These are the standard<br />    Sudoku boxes."""<br />    return [one_box(solution, i) for i in [0, 3, 6, 27, 30, 33, 54, 57, 60]]<br /><br />def splitup(solution):<br />    """Take a flat vector and make it 2D"""<br />    return [solution[i * DIM:(i + 1) * DIM] for i in xrange(DIM)]<br /><br />def consistent(solution):<br />    """Check how many different elements there are in each row.<br />    Ideally there should be DIM different elements, if there are no duplicates."""<br />    return sum(DIM - len(set(row)) for row in solution)<br /><br />def compare(xs1, xs2):<br />    """Compare two flat vectors and return how much they differ"""<br />    return sum(1 if x1 and x1 != x2 else 0 for x1, x2 in zip(xs1, xs2))<br /><br />def sudoku_fitness(flatsolution, puzzle, flatpuzzle=None):<br />    """Evaluate the fitness of flatsolution."""<br />    if not flatpuzzle:<br />        flatpuzzle = sum(puzzle, [])<br />    solution = splitup(flatsolution)<br />    fitness = consistent(solution) #check rows<br />    fitness += consistent(zip(*solution)) #check columns<br />    fitness += consistent(boxes(flatsolution)) #check boxes<br />    fitness += compare(flatpuzzle, flatsolution) * 10 #check that it matches the known digits<br />    return fitness<br /><br />def ga_sudoku(puzzle):<br />    """Return a fitness function wrapper that extracts the .genes attribute from<br />    an individual and sends it to sudoku_fitness."""<br />    flatpuzzle = sum(puzzle, []) #just a precalcing optimization<br />    def fit(guy):<br />        return sudoku_fitness(guy.genes, puzzle, flatpuzzle)<br />    return fit<br /></pre><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">I know. This made the solution less clean. Still, I made it verbose for readability, so it is perhaps less code than it looks.</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span><br /><span class="Apple-style-span" style="font-family: inherit;">Take that, random internet guy!</span><br /><span class="Apple-style-span" style="font-family: inherit;"><br /></span></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@blob Unfortunately I have no variable length genomes in optopus, but it is easy enough to create one yourself. Look at BaseGenome and perhaps take some inspiration from FloatGenome.</div>
</div>
<div class='comment'>
<div class='author'>blob</div>
<div class='content'>
Is there a built-in Genome that allows for a variable number of objects?<br /><br />Thanks! (:</div>
</div>
<div class='comment'>
<div class='author'>Stefaan</div>
<div class='content'>
I coded a Java GA for solving sudoku this year in a Meta-Heuristics course I took post grad. The best solving time I obtained from a few runs of AL Escargot was 9 minutes 41 seconds on a 2.66ghz core2 workstation, other problems took from sub one to 40 odd seconds depending on the difficulty. In the end the GA used four different methods of applying selection pressure, 4 more methods to then pare up parents, six different crossover methods, a modified island model and population restarting conditions&#8230; Needless to say comparitively to other meta-heuristics it is a very inefficient method.</div>
</div>
<div class='comment'>
<div class='author'>Cleve</div>
<div class='content'>
Human puzzle solvers and computers use very different approaches for Sudoku.  Humans are good at finding patterns.  Computers use brute force with genetic algorithms or other forms of recursive backtracking.  Take a look at:<br />   http://www.mathworks.com/moler/exm/chapters/sudoku.pdf</div>
</div>
<div class='comment'>
<div class='author'>Jerren</div>
<div class='content'>
So there is a GA to solve Sudoku.  That means there must be a constructive algorithm to solve it too.<br />What is the constructive algorithm?</div>
</div>
<div class='comment'>
<div class='author'>StartBreakingFree.com</div>
<div class='content'>
Pretty cool, so did it solve one sudoku puzzle or did it evolve an algorithm to solve sudoku puzzles in general?<br /><br />Thanks for posting it!</div>
</div>
<div class='comment'>
<div class='author'>micks</div>
<div class='content'>
Very interesting way to solve sudoku.<br /><br />I am just curious, exactly how long did it take for you to solve Sudoku? <br />I have a solution that solves Sudoku (among other tougher problems) very fast. <br />I just want to know your number before telling(bragging, as some might say) about mine.<br /><br />I just wanna compare the speed of the two solutions, yours and mine.<br />Really good post.</div>
</div>
<div class='comment'>
<div class='author'>vaevictus-net</div>
<div class='content'>
Seems like genetic algorithms for sudoku solutions are a decent example of GA.  But I think it might be fun/interesting to use GA to build some sort of logic engine to solve sudokus.  :)</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@albert<br /><br />I agree, that is a good approach.</div>
</div>
<div class='comment'>
<div class='author'>albert</div>
<div class='content'>
This is better:<br />http://norvig.com/sudoku.html</div>
</div>
<div class='comment'>
<div class='author'>Doug</div>
<div class='content'>
Damn, This is mind numbing good&#8230;</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2010/04/27/gates-in-practice/">Gates in Practice</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2010-04-27T00:00:00+02:00" pubdate data-updated="true">Apr 27<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Remember the classification problem from <a href="http://fakeguido.blogspot.com/2010/04/confident-optimization-using-gates.html">part 1</a>? I wrote a small script to simulate solutions with different success rates.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">For our first investigation, let us say that we have created 600 solutions. 400 of them have a true fitness 0.5 (a 50% chance to answer correctly - no better than random since our test cases are 50/50 positive and negative) and 200 of them have found something and have a true fitness of 0.6. One limitation to these simulations is that we assume that two different solutions with a fitness of 0.6 are totally uncorrelated on the tests, while in reality the solutions might very well have picked up on the same pattern and be completely correlated.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">In our hypothetical situation we have 300 different test cases that are out of sample, i.e not used by the process that created the solutions.300 test cases might seem like very few, but the circumstances are favorable. The 50/50 split between positive and negative helps. If it was just one positive in a hundred, many more cases would be needed. If the test cases are weighted, with some more important than others to get right, you also need more test cases.</div><div><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Running the 600 solutions through the 300 test cases, we might get the following histogram with 15 bins:</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX31h9Q7I/AAAAAAAAAEA/6fYx09jTTRw/s1600/Gate+histogram+for+peaks.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="482" src="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX31h9Q7I/AAAAAAAAAEA/6fYx09jTTRw/s640/Gate+histogram+for+peaks.png" width="640" /></a></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">If we could measure the fitness exactly, we would just see two bars - one at 0.5 and one at 0.6. Based on this graph, can we take the best solution and ask what is the probability that it is better than 0.55? 0.58? 0.62? It is hard to know. It really looks like there ought to be some solution better than 0.6.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">I divided the 300 tests into three gates with 100 in each. In some of my tests, no solution made it through all the gates, suggesting that I either needed more tests or more solutions, so just to test the theory I increased the number of 0.5-solutions to 100 000 and 0.6 to 50 000.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Running the solutions through the gates with a cutoff of 0.55 (meaning that we search for solutions that have a true fitness of 0.55 or better and only let those through that have a measured fitness of 0.55 on each gate) yielded the following result:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C0 = 150000</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C1 = 54774 (C0 / C1 = 2.74)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 35543 (C1 / C2 = 1.54)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 27891 (C2 / C3 = 1.27)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The ratios are decreasing nicely, as expected. I solved the equations in part 1 numerically, using my genetic algorithm library,&nbsp;<a href="http://code.google.com/p/optopus">optopus</a>, for Python, thus ending up with the following:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.34 good solutions, with 0.82 passing through each gate</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.66 bad solutions, with 0.14 passing through each gate</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">This means that the predicted probability of drawing a good solution after each gate is:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.34 (before any gate. True value is approx. 0.33)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.75 (after one gate. True 0.75)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.95 (0.95)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.99 (0.99)</i></div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">So in this particular special case, our method gets exactly the correct answer!</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Let us make it slightly harder and choose a cutoff that is not exactly in the middle between 0.5 and 0.6.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Running the solutions as above with cutoff 0.58 (we now ask how many are equal to or better than 0.58) yielded this:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C0 = 150000</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C1 = 35450 (C0 / C1 = 4.13)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 19571 (C1 / C2 = 1.81)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 11994 (C2 / C3 = 1.63)</i></div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Once again we get a nice decreasing ratio. Solving it numerically gets us these parameters</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.34 good solutions, with 0.62 passing through each gate</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.66 bad solutions with 0.04 passing through each gate</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">and these predicted probabilities of drawing a good solution after each gate:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.34 (True: 0.33)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.88 (0.88)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.99 (0.99)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.999 (0.999)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Ridiculously good!</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Let us make it harder still and pick a cutoff above the top solutions. This violates the assumption in part 1, that we have at least one good solution.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">With cutoff 0.62, I got this:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C0 = 150000</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C1 = 16043 (C0 / C1 = 9.35)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 4733 (C1 / C2 = 3.39)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C3 = 1400 (C2 / C1 = 3.38)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Here something worrisome happens. The ratio stops decreasing. Since this ratio is supposed to asymptotically reach the inverse of Pg, the probability that a good solution pass the gate, this should trigger an alarm. If we say that the fitness of a good solution has to be better than or equal to 0.62 and have a cutoff of 0.62 in the gates, how can only one in 3.38 pass? We should always get at least half of the good solutions through.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Running the GA gives:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.35 good, with a 0.3 probability to pass</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.65 bad with a 0.0004 probability to pass</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Which is completely wrong, since there are only bad solutions if we try to find solutions that are 0.62 or better. Remember that all our solutions have a true fitness of 0.5 or 0.6. We again get a stern warning that something is wrong, since a 0.3 probability to pass is too low. We expect at least half of the good solutions to pass. More than half should pass if the solutions are noticeably above the cutoff value, but anything under 0.5 means we are in trouble.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Taking that warning into account, it would seem that the gate test worked here as well.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><span class="Apple-style-span" style="font-size: x-large;">The problem</span></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Does it always work? Sadly, no. As I hinted in my last post, there is a problem. Let us say that instead of two kinds of solutions, 0.5 and 0.6, we have 100 solutions distributed evenly between 0.3 and 0.7. Just sending this solution distribution through the 300 tests yields (15 bins):</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX8HlcdWI/AAAAAAAAAEI/pcuKNok-R6s/s1600/Gate+histogram+for+even+dist.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="482" src="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX8HlcdWI/AAAAAAAAAEI/pcuKNok-R6s/s640/Gate+histogram+for+even+dist.png" width="640" /></a></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The distribution does not look very uniform anymore, but at least it looks like we have nothing over 0.7, which is true.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">With cutoff 0.65, we get:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C0 = 40000</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C1 = 4656 (C0 / C1 = 8.59)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C2 = 2385 (C1 / C2 = 1.95)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>C3 = 1392 (C2 / C1 = 1.71)</i></div><div><br /></div><div>Everything looks all right. Running the GA gives:</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.17 good, with a 0.58 probability to pass</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.83 bad with a 0.18 probability to pass</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.17 (True: 0.13)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.87 (0.68)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.99 (0.85)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><i>0.999 (0.93)</i></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">As can be seen, the algorithm overestimates how many good solutions there are. This happens because one of our initial assumptions, that there are only either good or bad solutions, is wrong. Since the C-ratios decrease, it looks like we get progressively more and more good solutions, which we are, but at a smaller rate than indicated. What happens is that the better a solution is, the more likely it is to survive, so the gates make sure that the better of the bad solutions survive, which makes a larger ratio of the entire &#8220;population&#8221; of solutions survive each time.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Note that the answer will not always be overestimated. If the even distribution is located mainly to the right of the cutoff, I think that the answer will instead be underestimated, but I have not yet tested this. It might be worth mentioning that running with cutoff 0.72 yielded very bad C-ratios, so that still works as before.</div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><span class="Apple-style-span" style="font-size: x-large;">Gates as transfer functions</span></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">A series of test cases and a cutoff value can be seen as a transfer function on the distribution of solutions. When the solutions are run through a gate, the transfer function is <a href="http://en.wikipedia.org/wiki/Convolve">convolved</a>&nbsp;with the solution distribution to yield a new solution distribution. In the graph below, I have plotted the transfer functions for five different gates, with the same cutoff but with different number of test cases. Once again we have relatively few test cases, but just as we discussed earlier, if the test cases are not divided 50/50 between positive and negative or there are weights, we need many more to get the same gate characteristics.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/_-8MSZS6yWdk/S9WV3GVHcHI/AAAAAAAAAEg/aJI4ZFzcr7c/s1600/Gate+Transfer+Functions+70.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="482" src="http://3.bp.blogspot.com/_-8MSZS6yWdk/S9WV3GVHcHI/AAAAAAAAAEg/aJI4ZFzcr7c/s640/Gate+Transfer+Functions+70.png" width="640" /></a></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The more test cases that the gate has, the steeper the transfer function. It will look more and more like a step function as the gate gets &#8220;larger&#8221;. In the limit that is actually is a step function (with infinitely many test cases), our earlier assumption fully holds and the predictions would again be correct. These transfer functions will move the solution distribution to the right (better true fitness). The only thing we can measure is still C, the number of solutions left, which in the continuous case would be the integral of the solution distribution.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><span class="Apple-style-span" style="font-size: x-large;">Possible solutions</span></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">If we knew the shape of our initial solution distribution and the shape of the transfer function, we would once again be in business and be able to predict the number of solutions above a cutoff correctly. The transfer function can be estimated, but the solution distribution can vary greatly. Maybe all solutions have the same true fitness? Maybe they are divided into two &#8220;pillars&#8221; as in the example above? Maybe they are spread in some more complex shape across the spectrum?</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Instead of just finding out the value of two points of the solution distribution (good and bad), we would get better estimates if we could get the value of more points. But knowledge of more variables require more equations. Where will these equations come from? We have two sources of untapped information.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">First of all, we have not used the exact result when the solutions are run against the test, only if they pass the cutoff or not. By letting the cutoff move from 0 to 1 and running the same gates over and over again, we can gain additional information on the shape of the solution distribution. If the transfer functions where linear, we would not gain additional information from this, but since they are not, the different resulting integrals can tell us something.</div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX_cQzHlI/AAAAAAAAAEY/AJtkYerEHtc/s1600/Gate+Transfer+Functions+with+9+Test+Cases.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="482" src="http://4.bp.blogspot.com/_-8MSZS6yWdk/S9VX_cQzHlI/AAAAAAAAAEY/AJtkYerEHtc/s640/Gate+Transfer+Functions+with+9+Test+Cases.png" width="640" /></a></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The results of the different cutoffs are of course not totally independent, so each new cutoff will not magically bring about a new independent equation, but it will still improve our understanding of the shape of the solution distribution.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The other source of information that we have not used is that not all solutions run against all test cases, since we filter out so many after each gate. This means that there are tests (thus information) that are not being used. The easiest way to use this information is to do as suggested in <a href="http://fakeguido.blogspot.com/2010/04/confident-optimization-using-gates.html">part 1</a>&nbsp;and rerun the gate experiment with the gates in different order. This will not give more equations, but will increase the accuracy of the measured Cs which in turn may allow more gates with fewer tests in each, which gives more equations.</div><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">This is my main approach and the one that I will test in practice and write my next post about.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">I have, however, two other rough ideas that one could pursue.</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">One approach is to abandon gates and look at the measured fitness histogram for all test cases (like the two I have shown above) and try to run it in reverse, by generating hypothetical true distributions and see how likely they are to end up in the measured distribution after the blurring effect of the test process. Maybe image deblurring techniques such as Gaussian&nbsp;<a href="http://en.wikipedia.org/wiki/Noise_reduction">noise reduction</a>&nbsp;can be used?</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">The other approach is to study&nbsp;<a href="http://en.wikipedia.org/wiki/Deconvolution">deconvolution</a>&nbsp;- the process of running a convolution in reverse. According to the Wikipedia article, deconvolution is often associated with image processing, where it is used to reverse optical distortion. Maybe this method will actually converge with the deblurring approach?</div><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;"><br /></div></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2010/04/14/confident-optimization-using-gates/">Confident Optimization Using Gates</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2010-04-14T00:00:00+02:00" pubdate data-updated="true">Apr 14<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
When dealing with any non-linear optimization or classification algorithm, like <a href="http://en.wikipedia.org/wiki/Genetic_algorithms">Genetic Algorithms</a>, <a href="http://en.wikipedia.org/wiki/Artificial_neural_network">Artifical Neural Networks</a> or <a href="http://en.wikipedia.org/wiki/Simulated_annealing">Simulated Annealing</a>, you need a way to compute the fitness of your candidate solutions. These algorithms all work in roughly the same way - you generate a solution, test it and generate new solutions based on feedback from the testing (the feedback will usually just consist of a fitness value).<br /><br />For some problems you can get the <i>true fitness</i> of a solution. If you, for example, are maximizing a known mathematical function of many variables, you immediately know exactly how good your solution is. However, for most interesting problems you will never know the true fitness. If you are evolving parameters for a poker playing program, a stock predictor or a walrus image classifier, you never know quite how good your solution is in general. The best you can do is try your solution on a number of test cases and assume that your average performance on those tests are the same as your average performance when the number of test cases approach infinity.<br /><br />An optimization algorithm will often become over-specialized in the test cases that it is trained on. To combat this, a method called &#8220;holdout validation&#8221; is often used. The data is divided up into several disjunct sets - a training set used for fitness calculation of the millions or billions of proposed solutions, a validation set for validating the fitness of solutions that are candidates of being the most promising so far and a test set for testing the final solution of your run. Often you will make several runs of your optimization algorithm with different types of inputs and parameters. The test set is used to decide which of the runs produced the best solution.<br /><br />This standard approach will sometimes work, but there are problems. If your fitness function is very volatile and test cases are hard to come by, you can never be quite sure how consistent your solution is. What is the chance that a solution will happen to get lucky on all three sets of test cases? Low? If I am persistent and keep running the same optimization problem on my computer cluster with the inputs prepared differently and different parameters until I get something that finally pass my tests, what are the risk that after billions and billions of tries, I have just found a fluke that will not perform well on further data? Obviously one can never be completely sure, but <b>it would be nice to at least know what the probability is that we have found a real solution</b>.<br /><br />One possibly more effective way of using your data is to employ&nbsp;<a href="http://en.wikipedia.org/wiki/Cross-validation_(statistics)">cross validation</a>, but if you test several solutions, the problems with &#8220;luck&#8221; will reappear.<br /><br />I&#8217;d like to explore a different theory that I have been tinkering with.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Gates - an introduction</span><br /><br />In this introduction, I will make a number of simplifications, assumptions and ungodly approximations. I hope to remedy this in the next post.<br /><br />Let us take the problem of walrus image recognition from the introduction. Imagine that we have a number of subaquatic images. Half of them depict sea weed, lobsters and whatnot and half are of walruses. A good walrus classifier will identify over 70% of the images correctly.<br /><br />Let us further make the assumption that a walrus classifier is either good or bad, with nothing in between. This assumption can not be entirely true, since an optimization algorithm needs a way to arrive at its solution through gradual improvement, which means that there must be somewhat good solutions. Nevertheless, it will have to do as an approximation for now.<br /><br />Assume we have a black-box algorithm that spits solutions at us. We will call the number of good solutions at a certain time <i>Sg</i> and the number of bad solutions <i>Sb</i>. The total number of solutions, <i>C0</i>, is just C0 = Sg + Sb.<br /><br />Take the images that the algorithm did not get to see and divide them randomly into three equally large sets. Each set is now a <i>Gate</i>, which will let through only those solutions that can correctly classify above 70% (it does not have to be the same as our target percentage) of the images in the set. We can assume that it is approximately equally hard to get through any gate. This assumption can be tested by simply sending our solutions through each gate and check that roughly the same number of solutions pass.<br /><br />Unfortunately there is a chance that a bad solution could get lucky and pass the gate (a false positive) or that a good solution could get unlucky and fail (a false negative), but for a meaningful test, a good solution must always have a better chance to pass the gate than a bad solution.<br /><br />Let us define the probability that a good solution passes a gate as <i>Pg</i> and the probability that a bad solution passes as <i>Pb</i>. As the number of test cases in each gate approaches infinity, Pg will approach 1 and Pb will approach 0.<br /><br />If we set up an experiment where we first send our solutions through the first gate, then send the survivors through the second and finally those survivors through the third gate, we can measure the remaining population size at four points. After the black box: C0, after the first gate: C1, second gate: C2 and third gate C3.<br /><br />If our gates are testing anything relevant and our population consists of both good and bad solutions (Sg != 0 and Sb != 0) we can immediately see that the ratio between successive gates should decrease C0/C1 &gt; C1/C2 &gt; C2/C3, because there will be a greater ratio of good solutions to bad solutions after each gate and Pg &gt; Pb. In plain English - a smaller percentage of the solutions should disappear each time, as the population gradually contains more good solutions. If this does not hold, we must either have bad gates (too few test cases or something) or no good solutions or no bad solutions. As the ratio of bad to good solutions decrease, C(i) / C(i+1) will approach Pg as most solutions will be good.<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Fortuitous results</span><br /><br />The number of good solutions that remain after the first gate is Sg * Pg and the number of bad is Sb * Pb. Thus we get four equations:<br /><br />C0 = Sg + Sb<br />C1 = Sg * Pg + Sb * Pb<br />C2 = Sg * Pg<sup>2</sup> + Sb * Pb<sup>2</sup><br />C3 = Sg * Pg<sup>3</sup> + Sb * Pb<sup>3</sup><br /><sup><br /></sup><br /><div style="text-align: center;"><sup><span class="Apple-style-span" style="font-size: medium;"><a href="http://4.bp.blogspot.com/_-8MSZS6yWdk/S8XNQldi6DI/AAAAAAAAADw/DABY2O4j6lc/s1600/SimplifiedGates.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/_-8MSZS6yWdk/S8XNQldi6DI/AAAAAAAAADw/DABY2O4j6lc/s320/SimplifiedGates.png" /></a></span></sup></div><br />Since we have four equations and four unknowns, Sg, Sb, Pg and Pb, we should be able to solve what the ratio of good to bad solutions is and what the characteristics of the gates are. Subsequently we can tell what the chance is that we pick a good solution if we randomly pick one after a certain number of gates. We can also tell how many solutions we will need to generate on average until we have at least one solution that passes through a certain number of gates.<br /><br />There is nothing magical about three gates. If we use more gates with fewer tests in each (thus making Pg and Pb closer) we will get different characteristics. This will result in more equations and the variables will be overdetermined, but they can still be determined using, for example, a least-squares fitting. Trying different number of gates and different gate sizes can help us find the optimal use of our test cases.<br /><br />It is important that Pg and Pb are roughly the same for each gate, in other words that one gate is not significantly harder or easier to pass through than the others. If the gate sizes are large this is more likely to be true. It is straightforward to test this assumption. You can either:<br /><br /><ul><li>Do the simple test described earlier, making sure that C is roughly the same for each gate.</li><li>Put the gates in different order and re-run the experiment, verifying that the results are the same.</li><li>Run the experiment several times, dividing the test cases into three entirely new gates each time and determine the standard deviation of the calculated parameters.</li></ul><br />If C is not roughly the same for each gate, you need larger gates. Go find more data or use fewer gates, but no fewer than three. That simple. (Almost.. we have not defined exactly how rough &#8220;roughly&#8221; is)<br /><br /><span class="Apple-style-span" style="font-size: x-large;">Caveat</span><br />So.. Is everything solved that easily? Can we now go out and confidently optimize the world as the title suggests? No, but I believe this approximation can be of great use as it stands. Earlier we made the assumption that solutions are either good or bad, instead of somewhere in a continuous fitness spectrum. In my next post, I will explain why this makes things a bit more complicated.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@JP I show some testing here: http://fakeguido.blogspot.com/2010/04/gates-in-practice.html</div>
</div>
<div class='comment'>
<div class='author'>JP</div>
<div class='content'>
It seems reasonable course. have you tested it yet? I mean compared to other methods.</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/12/21/why-planning-is-hard/">Why Planning Is Hard</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-12-21T00:00:00+01:00" pubdate data-updated="true">Dec 21<span>st</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
After my last post about planning I thought some more on the issue and had something close to an epiphany.<br /><br />When you plan, in the solitaire sense, you need rules governing what moves are legal - transformation rules. If you treat these rules like black boxes, just understanding them by playing around with positions and see how they behave, you can only do so much. An important rule might be usable extremely rarely, but nevertheless be the key to success if you specifically aim to reach a position where it is applicable. This means that you might miss how important a rule (or an exception to a rule) is, when just &#8220;black-boxing&#8221; it, because it&#8217;s usefulness or purpose might never come up.<br /><br />Even if you have no such rare rules in your system, the best you can hope for if you want to analyze a system when black-boxing is just to formulate your own internal rules for how the system seems to behave.<br /><br />Thus, <span style="font-weight: bold;">the reason planning is hard is that you need to be able to analyze/understand code to understand transformation rules in general</span> and understanding code is hard. You need to understand when you may take actions and what these actions do, i.e understand transformation rules, whatever system you are planning for.<br /><br /><span style="font-size:130%;">A small prediction<br /><br /></span>The reason why good planning is a key to analyze code and prove things in formal systems is that you need to understand code in order to plan. Thus, I postulate, when something can analyze code better than I, it will quickly learn to do everything else intelligence-based better than I. The implication probably works both ways, so the first program that is thoroughly smarter than I will most likely have it&#8217;s foundation laid upon the ability to reason about code.</div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Home Broker</div>
<div class='content'>
Hello. This post is likeable, and your blog is very interesting, congratulations :-). I will add in my blogroll =). If possible gives a last there on my blog, it is about the <A HREF="http://home-broker-brasil.blogspot.com" REL="nofollow">Home Broker</A>, I hope you enjoy. The address is http://home-broker-brasil.blogspot.com. A hug.<A HREF="8250556117" REL="nofollow"></A></div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/12/12/deceptively-simple-game/">Deceptively Simple Game</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-12-12T00:00:00+01:00" pubdate data-updated="true">Dec 12<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
I would pay a handsome sum (say $1 million, if I could raise it) for a program that could do the following well-defined, seemingly simple, task.<br /><br /><span style="font-size:130%;">General solitaire solver</span><br /><br />Take as input a list of rules for a solitaire-like game. The rules are deterministic transformation rules, defining which moves are legal given a certain position. The rules will be given in whatever Turing complete language the solver likes. For example a simple Scheme dialect without side-effects or a subset of x86 machine code.<br /><br />As long as it solves the task, the solver is free to treat the rules as <span style="font-style: italic;">black boxes</span> that take one position and outputs a, possibly empty, list of potential positions.<br /><br />The solver will then take an initial position as second input and one or more target positions as final input. In fact, to make it more general, take a function that tells whether a position is the target or not.<br /><br />As output, I want a sequence of transformations that leads from the initial position to a target. It does not have to be the shortest sequence, just a sequence. Also I want the answer reasonably fast. At least as fast as I could solve it myself.<br /><br /><span style="font-size:130%;">Extra features</span><br /><br />While I would be very happy with just the above, here are some extra features that would be nice.<br /><br /><ul><li><span style="font-size:100%;">Instead of a binary target function, let me use a continuous target function, and give as output a sequence that gives an end position with as good a score as possible.</span></li><li><span style="font-size:100%;">Accept one or more opponents. This would be useful for playing games - go, shogi, chess, etc, but apart from that would probably be a step towards the stochastic thing below.</span></li><li><span style="font-size:100%;">Allow the transformation rules to behave in a stochastic/probabilistic manner.</span></li></ul><span style="font-size:130%;">Why?</span><br /><br />I have no particular desire to solve solitaire automatically, so why would I want a generalized solitaire solver? Well, if you can input the rules for solitaire, you can also input the rules for <a href="http://seedai.blogspot.com/search/label/Towers%20of%20Hanoi">Towers of Hanoi</a>, which I used as an example of difficult planning in another post. Suddenly you can solve a whole range of reasoning problems, mathematical proofs, reasoning about programs and all sorts of interesting and important stuff.<br /><br />It is interesting to think about the problem from the point of view of solving solitaire or some other simple one-man game. I think it makes it less intimidating.</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/09/07/optimal-iq-test/">The Optimal IQ Test</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-09-07T00:00:00+02:00" pubdate data-updated="true">Sep 7<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
The hardest part for me when thinking about seed AI and optimal optimization, is coming up with a good fitness (IQ) test.  Since you need the test to run fast, you end up testing that the algorithm can get somewhere fast, i.e checking only the extreme beginning of a performance curve that ultimately must continue to be good many thousand times longer. What we want to measure is something like the <a href="http://en.wikipedia.org/wiki/Big_O_notation">Big O</a> performance of the algorithm in the limit and not what it looks like the first second of it&#8217;s life. Another problem is that we want the intelligence to be as general as possible and not over-specialized on solving a few test cases.<br /><br /><span style="font-size:130%;">A fitness test of a fitness test</span><br /><br />Recently I got a new idea of what constitutes a good IQ test. Our current approach to seed AI is about developing a really good programmer that can program better versions of itself. A good fitness test is a test that has a high correlation between a program testing good on it and the same program being able to generate new programs that gets even better scores. Not only is this a necessary criterion. It might be <span style="font-weight: bold;">sufficient</span>. Any test of a program which means that this program is likely to produce new programs that perform well (strictly - reach a new global optimum) on the test, might be a good fitness test of what we are after. The test that produces new <span style="font-style: italic;">Masters </span>(see <a href="http://seedai.blogspot.com/2007/09/1250-press-return.html">this post</a>) most frequently might be the best test. Getting the most new Masters over time, also ensures that the test does not take unnecessarily long to run. I am not completely sure, but we might need to force all tests to start with a kernel of an intelligence test (compress this string, predict this numeric sequence, something like that), just to set it of in the right direction and eliminate trivial solutions, like giving all programs a random IQ from some distribution. The trivial solution of giving all programs the perfect IQ, would not be a candidate, because no new globally optimal solutions would be found, so no new Masters would come, and thus that fitness test would not test well on the fitness test test (am I making sense?).<br /><br />Having a fitness test of our fitness test suggests that we can start by evolving a good test, or even more beautifully, co-evolve solution and test.<br /><br />Perhaps I am just dreaming, but it sure would be a beautiful algorithm if it worked&#8230;</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/09/06/coincidence/">Coincidence?</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-09-06T00:00:00+02:00" pubdate data-updated="true">Sep 6<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
I once read a short story about the creation of the world&#8217;s most powerful computer. In essence, each time they tried to turn it on, they had some minor misfortune, a power outage, the maid accidentaly tripped on, and unplugged, the power cord, etc. The highly technical twist in the end was that since we live in a <a href="http://en.wikipedia.org/wiki/Multiverse">Multiverse</a>, all things that can happen happens in a separate universe. It turns out that the computer was so advanced (or something) that it turned in to a black hole when switched on, destroying all life. Since the observers could only exist in the universes where the computer remained switched off, they experienced these &#8220;coincidences&#8221;, that protected them.<br /><br /><span style="font-size:130%;">A database of all human knowledge</span><br /><br />When I read up a bit on <a href="http://en.wikipedia.org/wiki/Cyc">Cyc</a>, the other day, I came upon a competing project that I, myself, once added some <span style="font-style: italic;">mindpixels</span> to.<a href="http://en.wikipedia.org/wiki/Mindpixel"> </a><blockquote><a href="http://en.wikipedia.org/wiki/Mindpixel">Mindpixel</a> was a web-based collaborative <a href="http://en.wikipedia.org/wiki/List_of_notable_artificial_intelligence_projects" title="List of notable artificial intelligence projects"></a>artificial intelligence project which aimed to create a database of millions of human validated true/false statements, or probabilistic propositions.</blockquote>Unfortunately the project is now defunct, since the founder Chris McKinstry committed suicide on <a href="http://en.wikipedia.org/wiki/23rd_January" title="23rd January"></a>23rd January, 2006.<a href="http://en.wikipedia.org/wiki/2006" title="2006"></a><br /><br />Well, never fear, because from the Mindpixel page on Wikipedia, we learn that <a href="http://en.wikipedia.org/wiki/Open_Mind_Common_Sense">Open Mind Common Sense</a> is a similar project, run by MIT, whose goal is to build a large common sense knowledge base from the contributions of many thousands of people across the Web.<br /><br />Unfortunately that<span style="font-weight: bold;"> </span>project is <span style="font-weight: bold;">also</span> stalling, since Push Singh who was slated to become a professor at the MIT Media Lab to lead the Commonsense Computing group in 2007, commited suicide on Tuesday, February 28, 2006. Just a month after the other visionary of web knowledge, Chris McKinstry.<br /><br />Let the unreasonable conspiracy theories commence.<br /><a href="http://en.wikipedia.org/wiki/Deaths_in_February_2006" title="Deaths in February 2006"></a></div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/09/05/1250-press-return/">12:50, Press Return</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-09-05T00:00:00+02:00" pubdate data-updated="true">Sep 5<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
The deed is done.<br /><br />I and my friend Nils made a &#8220;sprint&#8221; last night, where we finished the first version of our seed AI.<br /><br />First we made a simple IQ-function that tests how well a program (a Program Generator or <span style="font-style: italic;">PG</span>) can generate new programs (<span style="font-style: italic;">leaves</span>) from feedback of how close a leaf is to what we want.<br /><br />A PG that receives the best IQ so far gets a chance to generate new PG&#8217;s, in effect it becomes a Program Generator Generator. We call this state a <span style="font-style: italic;">Challenger</span>. When a Challenger generates a new PG with the best IQ so far, it has verified that not only does it have good IQ, but it can produce other programs with good IQ, and is thus promoted to the status of <span style="font-style: italic;">Master </span>(and the smart PG gets to be Challenger).<span style="font-style: italic;"><br /></span><br />The programs are generated and run in a circular buffer under a virtual machine, where all sequences of integers are valid programs and no operators can throw exceptions. Such a VM is much slower than machine code, but the process gets faster than if it were running on bare bones x86, because on an x86 (or other architecture) most bytes are meaningless and will throw exceptions, which are slow to process. A PG that is good enough (for example a human) to understand how to write code without generating (many) exceptions, would theoretically run faster on x86, but our current primitive PGs will benefit from a virtual environment.<span style="font-style: italic;"><br /><br /></span>Anyway, we wrote the code, pressed Enter (the title is a reference to the nice movie Pi), and voíla, our random generating seed started finding more intelligent programs than itself - Challengers. After a while, Nils calls it 15 seconds, a Challenger managed to become Master and after a longer while the Master produced a Challenger that later became the third generation Master. Spectacular!<br /><br />Now we just need a better IQ test and a way to inspect the generated programs! Well, we also need tons and tons of hardware. This is the sort of task that could happily use up Google&#8217;s entire computer armada for a year and still benefit from more. Hmm.. perhaps if I ask them nicely..</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2007/08/30/seed-ai/">Seed AI</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2007-08-30T00:00:00+02:00" pubdate data-updated="true">Aug 30<span>th</span>, 2007</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
<span style="font-size:130%;">Le grand assumption<br /><br /></span>The assumption of <a href="http://en.wikipedia.org/wiki/Seed_AI">seed AI</a> is this: <blockquote>If we can make a program intelligent enough, a &#8220;seed&#8221; of intelligence, we can also make it gradually improve itself.</blockquote>If intelligence can be expressed as a short formula (think Maxwell&#8217;s equations or E = mc<sup>2</sup>), we might not need to make a seed. We will simply have to find that formula. In general, the <a href="http://en.wikipedia.org/wiki/No-free-lunch_theorem">No-Free-Lunch theorem</a> implies that there must always be scope for improvement, but there are nevertheless some promising paths that I will post about some other time.<br /><br />Related to seed AI is the point where an AI can read and make sense of human text, such as Wikipedia, Principia Mathematica, etc. If we can reach that goal, an AI would quickly acquire superhuman cross-disciplinary knowledge, which in turn would help it to digest ever more advanced text. To get there, a program has to have plenty of common sense that we all take for granted. <a href="http://en.wikipedia.org/wiki/Cyc">Cyc</a> is an ambitious, long-running, project that tries to collect all this &#8220;common sense&#8221;.<br /><br />A superintelligent AI would be incredibly useful. Useful beyond your wildest fantasies. <sing>.<br /><br />A more intelligent program is likely harder to improve, but at the same time a more intelligent program is better at improving, so we can have reasonable hope for the improvement process to continue indefinitely (or perhaps converge to a single point - the formula for intelligence), although it is hard to guess what the improvement curve will look like. Will the difficulty increase much faster than the capacity? No one knows. It is tempting to make an analogy with humans and note how hard it is for us to rewire the brain to make us fundamentally more intelligent. For most programs this is probably very different. A program is made to be modified, it is software and not, as our brains, firmware or wetware.<br /><br />If we want to talk about improving programs, <span style="font-weight: bold;">we have to define what it means to improve one&#8217;s intelligence, and thus what it means to be intelligent</span>. We want intelligent systems to be useful. Useful intelligence is, just as science, about <span style="font-style: italic;">prediction, planning and pattern recognition</span>. These are all so intertwined as to be more or less the same thing.<br /><br /><span style="font-size:130%;">Prediction<br /><br /></span>Given certain input we want to predict what the outcome might be. It is nice if this prediction involves not only the most likely outcome, but also estimates of the probabilities of all the possible outcomes. Even better is if the predictor gives an indication for how certain it is about the probabilities.<br /><br />If I roll a regular dice, I am fairly sure that the probability of a 3 showing up is about 16.7%, of course the dice might be damaged or otherwise unfair, or perhaps I miscalculated 1 / 6 or misunderstand the laws of probability, etc. Neverthless, I am fairly certain. On the other hand, I estimate the probability of Sweden beating Brazil the next time they meet in soccer to about 10%, but I am fairly uncertain about that figure. Thus I should be cautious about acting on it, for example not taking bets. I am, however, quite certain that I am uncertain about my last probability estimation. It is probably not very useful to continue this recursion further, neither for me nor for a program, so I&#8217;ll be quite satisfied if my AI knows certainties concerning probabilities, but not certainties about certainties.<br /><br />Two classic examples where prediction is useful are weather forecasts and the stock market.<br /><br /><br /><span style="font-size:130%;">Planning</span><br /><br />Prediction is closely related to planning. One way of formalizing planning is to make an enormous tree, where each choice I can make is a branching point and every consequence along with it&#8217;s probability is also a branching point. In a complex world most of my millions of choices/actions will not have any bearing on me reaching a specific goal, so the tree gets unfeasibly large. The first step is to quickly <span style="font-weight: bold;font-size:100%;" >predict</span><span style="font-size:100%;"> which paths might actually have a significance towards me reaching my goal, thus pruning the tree. Then I have to </span><span style="font-weight: bold;font-size:100%;" >predict</span><span style="font-size:100%;"> what the consequences of my actions are likely to be, making a model of the outside world. Now I have a tree where I can start searching for a solution, in other words make a plan<br /><br />A classic example of a planning problem is <a href="http://en.wikipedia.org/wiki/Towers_of_Hanoi">Towers of Hanoi</a>. It is trivially easy to make a program that solves Towers of Hanoi, but it is harder to construct a general AI that, given the rules to the game, solves it in general. You cannot just exhaustively search your decision tree, because Towers of Hanoi with 30 discs requires 2^30 - 1= 1073741823 moves to complete. This means that the depth of the tree is 10^9 and, given at least two paths on each level, 2^(10^9) nodes. That amounts to more than a 1 followed by 300 million zeroes - a ridiculously large number. The planner must reason about the effects of the rules and <span style="font-style: italic;">recognize the pattern</span> for moving the discs.<br /><br /><br /><span style="font-size:130%;">Pattern recognition<br /></span><br />Recognizing patterns is, among other things, the useful property of being able to spot that given <span style="font-style: italic;">this</span>, <span style="font-style: italic;">that</span> follows more/less frequently. A neat way of deciding if you have spotted a pattern is to invoke <a href="http://en.wikipedia.org/wiki/Minimum_description_length">Minimum Description Length</a> or MDL. 10101010101010&#8230; can be described with the exact digits, or as a repeating pattern of 10s or as alternating 1 and 0. Which one is chosen depends on what language you have chosen to express your pattern in. For longer patterns it makes less and less difference what language you chose. The same reasoning applies to, for example, a picture. If we have a completely black 1000 x 1000 pixel square with a white 500 pixel (in diameter) circle in the middle , then that description is much shorter than actually encoding the image pixel for pixel. We have recognized a pattern.<br /><br />Notice the close relationship between pattern recognition and compression.<br /><br /><span style="font-size:130%;">Intelligence test<br /></span><br />Constructing a true intelligence test, that can be executed reasonably fast, would be very useful in the research of general AI. You have to be careful when designing such a test, because if it is too simple you will end up with an AI that is specialized on solving exactly your test and nothing else.<br /><br />If we had such a test, a fairly simple, but very interesting, experiment could be made.<br /></span></sing><ol><li><span style="font-size:100%;">Start with a program that produces random output. The seed!</span></li><li><span style="font-size:100%;">Measure its intelligence. This producer of random noise is now your first and most intelligent program.</span></li><li><span style="font-size:100%;">Interpret the currently best program&#8217;s output as new programs and measure the intelligence of these programs, give this intelligence as feedback to the generating program.</span></li><li><span style="font-size:100%;">Whenever a program that is more intelligent than the previous most intelligent program is found, use it as the new generator to search for even more intelligent programs.</span></li></ol><span style="font-size:100%;">You might need to add some precautions so that you do not enter an evolutionary dead end, for example by letting different promising generators run in parallell, but the above points are the basic gist of it. This will let you find out how much more time it takes for each successively more intelligent program to construct an even more intelligent program. If you are very, very, lucky and have constructed your intelligence test very well, this might even suffice as the Seed.<br /><br />In coming posts I will describe what the mathematically perfect predictor looks like and what the mathematically perfect planner looks like. They are, at least on the surface, surprisingly dissimilar.<br /></span></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>cognomad</div>
<div class='content'>
Thanks for the comment on my knol, David!<BR/>You&#39;re right, it sounds very similar on a high level, &amp; I am sure there are many people who&#39;d agree with the definition. But I don&#39;t know of anyone who used it to derive a universal, low-level, quantitative criterion to select inputs &amp; algorithms. The key is to start from the beginning: raw sensory inputs, &amp; &quot;test&quot; their predictive value, in the process discovering more &amp; more complex patterns. That&#39;s what scalability is all about, if you can&#39;t evaluate pixels, it&#39;ll be super-exponentially more difficult to start from more complex data. That&#39;s why I think Cyc, NLP, &amp; high-level approaches in general are hopeless for AGI.<BR/>I am sorry, but your &quot;Intelligence test&quot; idea, besides it being entirely hypothetical &amp; presumably externally administered, has it exactly backwards. Just like many Algorithmic Learning approaches, you want to generate patterns &amp; algorithms, instead of discovering them in a real world. Quite simply, we predict from experience, these patterns &amp; algorithms will have *no* predictive value beyond mere chance, unless they&#39;re derived from the experience. Notice that the difference between patterns &amp; algorithms is strictly in their origin: the former are discovered &amp; the later are &quot;invented&quot;.</div>
</div>
</div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/">A better algorithm for backups and rolling logs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/">Pre-programming Mental Silence Meditation with Entrainment</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/">Compile time loops in C++11 with trampolines and exponential recursion</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/31/c-plus-plus-11-and-boost-succinct-like-python/">C++11 and Boost - succinct like Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/09/28/no/">No, really. Use Zsh.</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/gurgeh">@gurgeh</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'gurgeh',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("fnedrik", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/fnedrik" class="twitter-follow-button" data-show-count="false">Follow @fnedrik</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - David Fendrich -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ifho';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




<a title="Real Time Analytics" href="http://getclicky.com/100529738"><img alt="Real Time Analytics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(100529738); }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100529738ns.gif" /></p></noscript>


</body>
</html>
