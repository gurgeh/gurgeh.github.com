
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>IFHO</title>
  <meta name="author" content="David Fendrich">

  
  <meta name="description" content="This post was inspired by Rob&#8217;s Soylent experiment. He recently got a lot of press for constructing an almost completely artificial liquid diet &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fendrich.se/">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="IFHO" type="application/atom+xml">
  <link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
  
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


  

</head>


<body   >
  <header role="banner"><hgroup>
  <div id="logo">
  <!--  <div id="logoLeft">{</div><div id="logText"><img src="/images/SimpsonDavid.png" width="36" height="36"></div><div id="logoRight">}</div>
  	<div class="clear"></div>-->
  </div>
  <h1><a href="/">IFHO</a></h1>
  
    <h2>In Fendrich's Humble Opinion</h2>
  
  <div class="clear"></div>
</hgroup>


</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:fendrich.se" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2013/04/09/a-better-soylent-good/">A Better Soylent - Designing a Simple, &#8220;Optimal&#8221; Nutrition Shake</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2013-04-09T14:54:00+02:00" pubdate data-updated="true">Apr 9<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/04/09/a-better-soylent-good/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This post was inspired by Rob&#8217;s <a href="http://robrhinehart.com/">Soylent</a> experiment. He recently got a lot of press for constructing an almost completely artificial liquid diet containing everything a human needs and then consuming this goo exclusively for a month.</p>

<p>Yes, of course it has been done before, but I thought the idea was interesting and wanted to try it myself. I am very interested in health and longevity, so I thought I&#8217;d incorporate what I consider the most important and well-founded dietary findings in my recipe. The final recipe (let&#8217;s call it &#8220;Goop&#8221;, like the food in The Matrix) will be quite cheap compared to regular food and include only natural vegetarian ingredients and a multi-vitamin (mostly for the vitamin D).</p>

<p>Nutrition is complicated. The most difficult part of any new dietary idea is that humans are extremely long lived, so it takes forever to verify the long-term effects. Also, most of us are not keen to be put in cages and fed on a rigorous schedule, so you never know quite what people really eat. You can probably tell a lot from mouse studies and you can monitor known health markers in humans, but there are no guarantees. I have not even tried this diet myself yet (though I will in just a few days). If you decide to give it a try, you do it completely at your own risk.</p>

<p>Even if you are not interested in my final recipe for a complete nutrition shake (or shake-like substance), you might find the general discussion on what to put in your body interesting.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/04/09/a-better-soylent-good/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2013/04/09/a-better-soylent/">A Better Soylent - Designing a Simple, &#8220;Optimal&#8221; Nutrition Shake</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2013-04-09T14:54:00+02:00" pubdate data-updated="true">Apr 9<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/04/09/a-better-soylent/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This post was inspired by Rob&#8217;s <a href="http://robrhinehart.com/">Soylent</a> experiment. He recently got a lot of press for constructing an almost completely artificial liquid diet containing everything a human needs and then consuming this goo exclusively for a month.</p>

<p>Yes, of course it has been done before, but I thought the idea was interesting and wanted to try it myself. I am very interested in health and longevity, so I thought I&#8217;d incorporate what I consider the most important and well-founded dietary findings in my recipe. The final recipe will be quite cheap compared to regular food and include only natural vegetarian ingredients and a multi-vitamin (mostly for the vitamin D).</p>

<p>Nutrition is complicated. The most difficult part of any new dietary idea is that humans are extremely long lived, so it takes forever to verify the long-term effects. Also, most of us are not keen to be put in cages and fed on a rigorous schedule, so you never know quite what people really eat. You can probably tell a lot from mouse studies and you can monitor known health markers in humans, but there are no guarantees. I have not even tried this diet myself yet (though I will in just a few days). If you decide to give it a try, you do it completely at your own risk.</p>

<p>Even if you are not interested in my final recipe for a complete nutrition shake (or goo), you might find the general discussion on what to put in your body interesting.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/04/09/a-better-soylent/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/">A Better Algorithm for Backups and Rolling Logs</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2013-02-22T17:46:00+01:00" pubdate data-updated="true">Feb 22<span>nd</span>, 2013</time>
        
         | <a href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>In your <code>/var/log/</code> you will most probably have logs that have grown too large and rolled over. Per default your system logger gzips and stores a few of the older ones and finally when they get too numerous, it just deletes them. Same thing for log handlers in most languages, for example Python&#8217;s RotatingFileHandler. Backups are usually also handled the same way, when you don&#8217;t want to store every backup.</p>

<p>That is almost never what I want. If I store only N backups, I don&#8217;t want them to be only the very latest. If they are close in time they will be more similar and in some sense contain less information than backups that are spread out over time. Of course the newer ones are probably on average more interesting to me, so I don&#8217;t want them evenly spread over time. The following simple algorithm is my suggestion for a better way to handle rotating logs and backups.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/">Pre-programming Mental Silence Meditation With Entrainment</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2013-01-24T16:01:00+01:00" pubdate data-updated="true">Jan 24<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I am not a dirty hippie. No, honestly, I&#8217;m not. I am, in fact, a grumpy, skeptical, philosophically materialist atheist. Yet, on and off for the last 15 years I have practiced meditation.</p>

<p>It feels good, helps me relax and it makes my mind feel clear, perceptive and sharp afterwards. It was only recently that I started doing it in conjunction with programming. The match was so good, that I felt the proselytic urge to share what I had found. My example is programming, but it can obviously be any intensive, possibly creative, mental task, such as writing, studying or playing Yahtzee.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/">Compile Time Loops in C++11 With Trampolines and Exponential Recursion</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-11-22T15:05:00+01:00" pubdate data-updated="true">Nov 22<span>nd</span>, 2012</time>
        
         | <a href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Nowadays with <em>constexpr</em>, we can make pure functions that are
calculated compile time. The restriction on these functions is that
they may only consist of one statement (though additional lines with
typedefs, static_assert, etc are OK), and this statement may only call
other constexpr functions.</p>

<p>If-statements are easy - just use the ternary ?: operator or, if you
want to show off, template specialization. But the only way to loop
with these restrictions is by using recursion. Furthermore, neither
clang 3.1 nor GCC 4.7 (nor the current build of GCC 4.8) support tail
call elimination in these constexprs, so normal linear loops will
still eat stack space if we loop for a while. Also, the standard
recommends that the default maximum recursion depth should be 512,
which means that if we want to do something silly/fun/interesting
compile time, we have to mess with proprietary compiler switches to
get the program to compile. No fun.</p>

<p>In this post, I show one way of working around those limitations.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2012/10/31/c-plus-plus-11-and-boost-succinct-like-python/">C++11 and Boost - Succinct Like Python</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-10-31T13:05:00+01:00" pubdate data-updated="true">Oct 31<span>st</span>, 2012</time>
        
         | <a href="/blog/2012/10/31/c-plus-plus-11-and-boost-succinct-like-python/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>C++11 is the new standard of C++ that was released last year. Yes, I know that is now 2012, but compilers are just now starting to catch up and implement everything, though AFAIK there is not yet a fully compliant compiler.</p>

<p>With a combination of C++11 and the <a href="http://www.boost.org/">Boost</a> library, I think that it is possible to write code in a style that is almost as painless as in a modern dynamic language like Python. I also think that is not so well known how much C++ has changed for the better, outside the C++-community. Hence this post.</p>

<p>As an example, I have taken the first interesting excercise from <a href="http://www.diveintopython.net/toc/index.html">Dive into Python</a>, <a href="http://www.diveintopython.net/object_oriented_framework/index.html">fileinfo.py</a>, and converted it to C++, trying to remain as faithful as possible to the original code.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/10/31/c-plus-plus-11-and-boost-succinct-like-python/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2012/09/28/no/">No, Really. Use Zsh.</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-09-28T13:23:00+02:00" pubdate data-updated="true">Sep 28<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/09/28/no/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://zsh.sourceforge.net/">Zsh</a> is the new hotness. Well newer and hotter than Bash anyway, since the first version of Bash was released in June 1989, while the young and peppy Zsh was released in December 1990. In large parts thanks to the configuration &#8220;skin&#8221; <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>, Zsh has gained a lot of popularity during the last year or so. I have used it for a few months myself and could not be happier, unless it produced chocolate ice cream ‚Üê <em>note to shell developers</em>.</p>

<p>This is a guide on why you need it and how you install, configure and use it. Sometimes just with links to the relevant sites.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/09/28/no/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2012/09/27/octopress-and-github-as-blogging-platform/">Octopress and Github as a Blogging Platform</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2012-09-27T16:37:00+02:00" pubdate data-updated="true">Sep 27<span>th</span>, 2012</time>
        
         | <a href="/blog/2012/09/27/octopress-and-github-as-blogging-platform/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I have switched from Blogspot to <a href="http://octopress.org">Octopress</a>. Any self respecting coder should realize that 1) blogging is text and 2) text should be in revision control. Also 3) blogging is public text, so the revision control can be on a public server, like Github.</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2012/09/27/octopress-and-github-as-blogging-platform/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2011/11/10/guerilla-my-attempt-to-build-strong-ai/">Guerilla - My Attempt to Build a Strong AI</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2011-11-10T00:00:00+01:00" pubdate data-updated="true">Nov 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Having given the topic of artificial general intelligence (or AGI) a fair amount of thought over the last decade, a plausible path forward, based on something like an encyclopedia for algorithms, has slowly congealed in my head. I need to write it down before I start coding. Preferably in the form of a blog post, to get feedback. This is that post.<br /><br /><span class="Apple-style-span" style="font-size: large;">Background</span><br /><br />When I write about strong AI or AGI, I mean an algorithm with general problem solving skills. Not necessarily a mind inhabiting a robot, running around talking to people and passing the Turing test (though eventually a successful AGI could be taken in that direction), but rather something that can be applied to a wide variety of problems. For example: playing chess and poker, picking stocks, solving puzzles, proving math theorems, analyzing and writing computer code, speech and image recognition, improve itself by learning and self modification, etc.<br /><br /><br />There is an alluring approach to AGI, where you begin with a &#8220;simple&#8221; seed program, which will learn and self improve and eventually evolve to human intelligence and beyond. I think that in practice, the problem is that it has taken lots of people lots of time to invent all those algorithms that can be useful in general problem solving.&nbsp;Humans are pretty good at general problem solving - certainly much better than the best software/hardware combination we have today. Constructing algorithms to solve specific problems is in itself a kind of problem solving, and we humans have certainly invented many different algorithms for a wide variety of purposes. One might suspect that&nbsp;the computational depth of inventing/discovering algorithms is very large.&nbsp;So unless the seed program is actually very advanced, more like a full grown Sequoia than a seed, it might take too much time for it to invent all those algorithms and heuristics that we, as a civilization, already have.<br /><br /><br />Topics that are potentially useful to understand include:<br /><br /><br /><ul><li>Statistics (Bayes rule, distributions, Markov chains, running an experiment, etc).</li><li>Algorithms for optimizing parameters (genetic algorithms, simulated annealing, steepest descent, linear programming, random testing and purely analytical methods). In some situations it could take days or more to try a single parameter configuration. In other situations evaluating the fitness of a parameter configuration is just a couple of CPU instructions. Approaching these different tasks require a variety of methods</li><li>Logic</li><li>Basic mathematics (calculus, algebra, geometry, etc)</li><li>Code analysis (lambda calculus, etc)</li><li>Formal proof methods (knowledge of the methods listed here: http://en.wikipedia.org/wiki/Mathematical_proof) and formal reasoning</li><li>Tree and graph searching (depth-first, breadth-first, A*, beam, minimax, alpha-beta, Dijkstra)</li><li>Bayesian belief networks</li><li>Pattern recognition</li><li>Compression</li><li>Monte Carlo method</li><li>Clustering and classification</li><li>Fourier transforms, wavelets</li><li>Function approximation (analytical or with neural networks or genetic programming)</li><li>Inverting functions (in other words, given a program function and its output tell me what the input was - this turn out to be a very general way of posing questions)</li></ul><br /><div>&#8230;and of course many more.</div><div><br /></div><div>I consider statistics and parameter optimization to be the most important areas for intelligence, since you need them to learn. Pattern recognition (perhaps implemented with statistics and optimization) and various forms of tree searching are also vital.</div><br /><span class="Apple-style-span" style="font-size: large;">An encyclopedia of algorithms</span><br /><br />My approach is based on implementing an encyclopedia of useful algorithms that:<br /><br /><ol><li>Know to which tasks they can be applied</li><li>Can give a rough, initially often ridiculously rough, estimate of what the probability is that they solve the task after a certain time or, in the case of an open-ended task such as optimization, can give a rough estimate of how well the task is solved after a certain time.</li><li>Can continuously update the estimate as the task is solved</li></ol><br />It is important to stress that it is not enough to just implement a library of algorithms that can work on the same datastructures. The important thing is that you need metadata, describing when an algorithm can be used and the algorithmic complexity in time and memory. With time, you want to automatically build up more knowledge of the algorithms, gradually improving the time and success estimations as well as improving your knowledge of which algorithms are suitable in which situations.<br /><br />The algorithms should be broken up into as many natural subtasks as possible, so that when new algorithms are added to the system, they can try to solve these subtasks as well, thus creating new hybrid algorithms.<br /><br />A <i>task</i> is basically a function call together with its arguments. An algorithm that can solve a task implements the corresponding function and a time/success estimator. Similarly to function overloading in C++, the function header might state specializations, additional properties, of the function arguments that must be true for the algorithm to be a contender to solve it. It is important that the <i>Scheduler</i> (see below) immediately knows which algorithms are suitable for a certain task, so the mentioned &#8220;additional argument properties&#8221; must be immediately available. If a certain property requires work to find out - &#8220;is the list in the first argument sorted?&#8221; - and an algorithm still needs it, a new algorithm can be constructed that first checks if the list is sorted and then either fails or asks the task again with the new property set. This new algorithm would have higher estimates of running time and lower estimates of success than the original algorithm.<br /><br /><span class="Apple-style-span" style="font-size: large;">The Scheduler</span><br /><br />When a task is added to the task pool it always has a <i>price</i> attached to it. The Scheduler runs those algorithms that currently promise best expected price per time unit. Algorithms that need subtasks solved has to assign a price to those too, before adding them to the task pool. That price should reasonably reflect how much of the overall time the subtask is expected to take. If it turns out that a subtask consistently take a smaller or larger fraction of the estimated total time, there should be algorithms that modify the price for these subtasks and correspondingly the total time estimate (also, see <i>Self Improvement</i> below).<br /><br />Open-ended tasks where something should be optimized cannot have just one value attached to them. Instead they need to have a function from achieved performance to price, or at least a rough mapping from some performance values to price. This mapping stops the system from optimizing for too long on a relatively unimportant subsubsubtask somewhere.<br /><br />Algorithms that can either fail or succeed on a task need a similar mapping, where they give probability of success as a function of time.<br /><br />One can also imagine that the algorithms could give a confidence interval or standard deviation on their estimates to tell the Scheduler how sure they are of their estimates, but I am not quite sure how this should be used, so for now they won&#8217;t.<br /><br />For my first try, the Scheduler will use a simple heuristic. The algorithm that claims to have the best price / time ratio for any task currently in the task pool will get to run it. For one thread this will be optimal in some sense. It gets more complex when you have many algorithms running in parallel on multiple cores or even clusters. For example, you want to slightly punish two algorithms trying to complete the same task in parallel, since the first one to succeed will always make the other algorithms work moot. On the other hand sometimes it makes sense to attack an important problem from several angles, so you don&#8217;t want to forbid it entirely either.<br /><br />In a later design, the Scheduler should be able to use the task pool to think about how it should Schedule. Obviously this must not end in an infinite Scheduling loop or general inefficiency, since normally the Scheduler must work very quickly.<br /><br />The Scheduler&#8217;s work and indeed that of the whole system will not be especially interesting when there are only a few algorithms implemented. The first interesting moment will be when new hybrid algorithms emerge, where subtasks are sometimes handled by unanticipated algorithms. I am not sure how many algorithms needs to be implemented for the system to show interesting emergent behaviour. Probably more than ten, but less than a hundred, depending, of course, on which algorithms and what you count as an individual algorithm.<br /><br /><span class="Apple-style-span" style="font-size: large;">Self improvement</span><br /><br />From the above, you can see that the system will not be self improving at first. However, by adding self improvement tasks, it will start doing things like improving the time estimates of the algorithms, learn to what degree one algorithm&#8217;s failure to solve a task should also reflect on the estimates of other algorithms, learn which situations are suitable for which algorithms; for example which algorithms perform well on the subtasks posted from a certain algorithm. It can also have an algorithm that constructs new lower-priced training tasks from real tasks, for example generalizations or specializations of a problem, just out of &#8220;curiosity&#8221;.<br /><br />Producing new/improved code and algorithms, either for self improvement or as the solution for a puzzle or some other task, is among the most advanced tasks the system can try. It will not be able to do much of interest in this area until it is really strong, but it could start out by trying simple modifications of existing algorithms or trying them on similar tasks, a bit like in genetic programming.<br /><br />The system is also inherently self improving from a sort of network effect, since for each algorithm added, the existing algorithms get potentially better.<br /><br /><span class="Apple-style-span" style="font-size: large;">What now?</span><br /><br />When I have implemented the base system, I will start by applying the AGI to function inversion. Trivial stuff at first, of course, but I hope to eventually make it solve real puzzles like Towers of Hanoi by a combination of searching and deduction. Also, it would be fun to try some games and an NP-complete problem like 3-SAT.<br /><i><br /></i><br />It would be beautiful if the algorithms were written in the same simplified, purely functional (thus easier to analyze), LISP that I plan to write the problem definitions in. Alas, good AI needs to be fast and a 100x slower system just because the algorithms run in my own immature poorly interpreted language instead of C is not so fun. However, a good JIT compiler is a very good test for an AGI. You continuously have to weigh optimization time against running what you have. If the AGI in some distant future JITs its own code, effectively running and optimizing itself, I will consider the entire project a grand success :).<br /><br />I forget why I called the project Guerilla. It was probably terribly clever. Nevertheless, here is the link to the Github repository:&nbsp;<a href="https://github.com/gurgeh/Guerilla">https://github.com/gurgeh/Guerilla</a>. It does not contain much yet.<br />  <div class="zemanta-pixie" style="height: 15px; margin-top: 10px;"></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>sm4096</div>
<div class='content'>
Ai building efforts start at definitions:  Ai that can<br />specify goals and weight them , acquire combine breakdown and refine strategy.<br /><br />A strategy specifies goals, their desirability and at what likelihoods to take what actions on what (set of) conditions. <br /><br />Devising strategies can be broken down into:<br />creating and assessing conditions for actions,<br />weight of goals, estimates of cost for actions,<br />estimates of effectiveness of actions, finding related strategies,<br />taking strategies apart,<br />combining strategies,<br />covering contingencies,<br />evaluating strategies</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
I would be interested to see the input from which this AI (when implemented) would be able to learn how to play the 5-in-a-row game.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
This comment has been removed by the author.</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@acetoline No, the project is not abandoned, but thanks for asking :). I tend to post infrequent, overambitiously long posts, so a few weeks silence is normal.<br /><br />The reason the github activity is low is more silly. I am currently in something between the design and implementation stage, writing Python code with a few pseudocode elements and a lot of prose. For some reason, I have not considered this semi-code &quot;commit-worthy&quot;.<br /><br />I promise a github update this week.</div>
</div>
<div class='comment'>
<div class='author'>acetoline</div>
<div class='content'>
Hi, I noticed there hasn&#39;t been any activity on your blog or github lately. I hope you haven&#39;t abandoned the project.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Doesn&#39;t sound like a well scalable solution. Don&#39;t get overexcited/misled after some early luck in well defined toy worlds. With teaching by manual algorithm entry by techies, you aren&#39;t gonna get very far.</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
Hopefully, yes, it should be able to solve general problems using more specialized algorithms working together. It will not, however, take a set of specialized algorithms (let&#39;s say playing chess, checkers, poker and backgammon) and produce a general game playing algorithm. That is not how it achieves generality.<br /><br />It is geared towards very technical users. It takes input tasks as snippets of code and gives a  set of inputs that makes the function output true. This is called function inversion and is a fairly simple way of describing puzzles and technical problems.<br /><br />If it turns out to be a useful system for solving these types of tasks (a big IF - no one has really been able to achieve that). It would be a very good base on which to build something that can communicate with non-technical users and interact with our fuzzy world. That is not it&#39;s primary purpose, though.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Can this &#39;AGI&#39; generate general algorithms from a set of relevant non-general algorithms? Will non-technical users be able to teach this AI by describing specific (/non-general) scenarios?</div>
</div>
<div class='comment'>
<div class='author'>Daivd</div>
<div class='content'>
@Jiri Swedes, Norwegians, Danes and many Finns can read Swedish. That makes up a good 0.3% of the earth population :).<br /><br />Actually, I will remove that. That source code is not for human consumption yet. It is just test cases for analyzing source code, written in an odd Lisp dialect. No actual code relating to implementing either any of the algorithms I write about or the Scheduler.</div>
</div>
<div class='comment'>
<div class='author'>Mentifex</div>
<div class='content'>
One way to build a strong AI is outlined in the <a href="http://mind.sourceforge.net/aisteps.html" rel="nofollow">http://mind.sourceforge.net/aisteps.html</a> and develops into a simple but gradually <a href="http://www.scn.org/~mentifex/AiMind.html" rel="nofollow">expandable AI Mind</a>.</div>
</div>
<div class='comment'>
<div class='author'>Jiri Jelinek</div>
<div class='content'>
Don&#39;t use Swedish in the source, man! &#39;Nobody&#39; can read that ;-)</div>
</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <!-- Now we're back to normal posts. Note the links used under href in both headers.-->
        <h1 class="entry-title"><a href="/blog/2010/12/28/compression-prediction-and-artificial/">Compression, Prediction and Artificial Intelligence</a></h1>
      
    
    
      <p class="meta">
        








  


<time datetime="2010-12-28T00:00:00+01:00" pubdate data-updated="true">Dec 28<span>th</span>, 2010</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div class='post'>
Compression is one of the most powerful concepts in computing. For the normal computer user, compression is associated with making files smaller, so you can store more of them or send them faster over the Internet, but there is much more to it.<br /><br />An optimal compressor can (or could, if it existed) be used for prediction of the future of a sequence of events (weather, sports, stocks, political events, etc), for example by trying all possible continuations and examine how well it compresses given the history. Conversely, an optimal predictor that gives the correct probability of each possible next symbol can be used for optimal compression by using <a href="http://en.wikipedia.org/wiki/arithmetic_coding">arithmetic coding</a>.<br /><span class="Apple-style-span" style="font-size: large;"><br /></span><br /><span class="Apple-style-span" style="font-size: large;">Compression and prediction</span><br /><br /><i>This section on background theory contains possibly scary math and dense prose, but should be understandable for most programmers. Maybe re-read the sentences a couple of times.</i><br /><br />Ray Solomonoff has shown&nbsp;<a href="http://www.theworld.com/~rjs/chris1.pdf">[PDF]</a>&nbsp;&nbsp;that if we let Sk be the infinite set of all programs for a machine M, such that M(Sk) gives an output with X as prefix (i.e the first bits of the output is X), then the probability of X becomes the sum of the probabilities of all of its programs, where the probability of a program is&nbsp;2 ** (-|Sk|) if |Sk| is the length of the program in bits and &#8220;**&#8221; means &#8220;to the power of&#8221;. As X gets longer, the error of the predictions approach zero, if the error is calculated as the total squared probability difference.<br /><br />A technicality is that only those programs count, that does not still produce X, when the last bit of the program is removed.<br /><br />To give a slightly more concrete example, say that you have a sequence of events - a history - and encode those as a sequence of symbols, X. Let us further say that you have a machine, M, that can read a program S and output a sequence of symbols. If you have no further information on your sequence of events, then the best estimate for the probability of a symbol Z to occur next (i.e the best prediction) is given by the set of all programs that output your history X followed by Z. Programs which output X+Z and are short are weighted higher (the 2 ** (-|Sk|) part).<br /><br /><br /><div style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Even more concretely, given the binary sequence 101010101, you wonder what the probability is that the next bit will be 0 given that you know nothing else of this sequence. Sum 2 ** (-program length) for all programs that output 1010101010 vs those that output 1010101011 as their first bits (they are allowed to continue outputting stuff). If we call these sums sum0 and sum1 respectively, then the probability of 0 coming next is sum0 / (sum0 + sum1) and the probability of 1 coming next is sum1 / (sum0 + sum1).</div><br /><br />Obviously you cannot find all these programs by just trying every possible program, because 1) they are infinitely many and 2) given <a href="http://en.wikipedia.org/wiki/Halting_problem">the halting problem</a> you cannot in general know if a running program is in an infinite loop or if it will eventually output X.<br /><br />There is an area of probability theory called <a href="http://en.wikipedia.org/wiki/Minimum_description_length">Minimum description length</a>, where the language is chosen to be so simple (not Turing complete) so that you can actually find the shortest program or &#8220;description&#8221;. Calculating probabilities this way is very similar to Bayesian probability, but more general.<br /><br /><span class="Apple-style-span" style="font-size: large;">Solomonoff in (almost) practice</span><br /><br />Although the point of the theorem is not to apply it directly in practice, for short sequences X we can actually try. We can avoid problem 1 above, there are infinitely many programs, by generating random programs and see if they produce X. If they do, we count them. This way we can produce an approximation of what the true sum0 and sum1 are. If we set up our random generation such that shorter programs are more likely, then we don&#8217;t have to bother with the 2 ** (-program length) part and may just have a running count for each sum. If the sequence is too long, this method will be impractical since almost no randomly generated programs will actually output X.<br /><br />Problem 2 above, when we test programs they may not halt, is harder, but Levin has proposed a way around it. If we in addition to program length use running time (number of instructions executed) as a measure of the probability of our program, we can start by generating all the programs that we intend to test and then run them all in parallel. As our execution moves forward, we will get an increasingly accurate approximation of the true sum0 and sum1, without getting stuck on infinite loops.<br /><br />If we want to get even more practical, it can be shown that the shortest program that produces X will generally dominate the others and thus it will predict the most likely next symbol. That way you can just search for programs that output X and the currently shortest program will be your best guess. Since we no longer care about the relative probability of the next symbol, but only which is most likely, the search does not have to be random. Thus we can use any method we like for finding a short program. If you search for programs that produce X and find one that almost does, you can construct a &#8220;true&#8221; solution from that one, by constructing a prefix part that hard codes the places where your original program is wrong. This will produce a longer program, where the length, and thus the &#8220;score&#8221;, is the length of the prefix + the length of your faulty solution. The size of the shortest program that outputs X is called the <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a> of X. The size of the shortest program that outputs X, measured in program size + log(running time), is called the <a href="http://www.scholarpedia.org/article/Algorithmic_complexity">Levin complexity</a> of X.<br /><br />One way to find these programs is to use <a href="http://en.wikipedia.org/wiki/Genetic_programming">genetic programming</a>, just take care that you don&#8217;t think that you can count the number of programs that produce X and get relative probabilities, because your search will now be skewed towards the solution (and thus its prediction) that you find first.<br /><br />A small problem is that depending on what machine you choose, i.e which instructions your programs can use and the length of these instructions, you will get different results. The method has a built in bias, since there is no one correct Turing complete language. This difference will however be smaller as X gets longer. One way to understand that is to note that any Turing complete language can emulate any other Turing complete language and that the size of such an emulator is finite. This is called the compiler theorem.<br /><br /><span class="Apple-style-span" style="font-size: large;">Compression is understanding and the Hutter Prize</span><br /><br />When we understand something, we can describe it succinctly. If I have an image of a red perfect circle, the size will be much larger if I describe the individual pixels rather than just say &#8220;a red circle of diameter d and thickness t&#8221;. When I understand what the image is depicting, I can describe it shorter. Sometimes a lossy compression of observed data will actually express the truth better than the exact data. If I take a photo of a red circle, the photo will probably not be perfect, but if I notice what the photo is showing, I can compress it as &#8220;a red circle&#8221; and some noise which I throw away, and suddenly my lossy compression is a better depiction of the truth.<br /><br />This equivalence between compression and general intelligence led Marcus Hutter to announce the <a href="http://prize.hutter1.net/">Hutter Prize</a>, where money is awarded for the best compression of 100 megabyte of English Wikipedia articles. So far the compression algorithms have been impressive (compressing the text to about 15%), but not shown much intelligence or understanding of the articles. When they do start to exhibit some understanding, I think that if they are allowed to compress the data in a slightly lossy way, the first thing that will happen is that some spelling and layout mistakes will be corrected, because these will be surprising to the compressor and thus demand an unusually long representation.<br /><br />Matt Mahoney has written a good rationale on the Hutter Prize <a href="http://cs.fit.edu/~mmahoney/compression/rationale.html">here</a>.<br /><br /><span class="Apple-style-span" style="font-size: large;">Compression in practice - the juicy stuff</span><br /><br />Compression is a powerful tool to measure success and avoid overfitting in a variety of common AI problems. The methods I laid out here are interesting mostly from a theoretical perspective, because of their prohibitively long running times.&nbsp;In my next post, I will expand on my thoughts on how you can use these results to get actual, practical algorithms for common AI problems.<br /><span class="Apple-style-span" style="font-size: large;"><br /></span></div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/04/09/a-better-soylent-good/">A better Soylent - designing a simple, &#8220;optimal&#8221; nutrition shake</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/09/a-better-soylent/">A better Soylent - designing a simple, &#8220;optimal&#8221; nutrition shake</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/22/a-better-algorithm-for-backups-and-rolling-logs/">A better algorithm for backups and rolling logs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/24/pre-programming-mental-silence-meditation-with-entrainment/">Pre-programming Mental Silence Meditation with Entrainment</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/22/compile-time-loops-in-c-plus-plus-11-with-trampolines-and-exponential-recursion/">Compile time loops in C++11 with trampolines and exponential recursion</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/gurgeh">@gurgeh</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'gurgeh',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("fnedrik", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/fnedrik" class="twitter-follow-button" data-show-count="false">Follow @fnedrik</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - David Fendrich -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'ifho';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>




<a title="Real Time Analytics" href="http://getclicky.com/100529738"><img alt="Real Time Analytics" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a>
<script src="//static.getclicky.com/js" type="text/javascript"></script>
<script type="text/javascript">try{ clicky.init(100529738); }catch(e){}</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100529738ns.gif" /></p></noscript>


</body>
</html>
