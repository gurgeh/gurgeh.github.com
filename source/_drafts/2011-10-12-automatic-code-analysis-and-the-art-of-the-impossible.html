---
layout: post
title: "Automatic code analysis and the art of the impossible"
date: 2011-10-12
comments: false
---

<div class='post'>
<span class="Apple-style-span" style="font-size: large;">All I want for Christmas...</span><br /><br />I would&nbsp;<i>really</i>&nbsp;like to write a program that is good at understanding and analyzing code. Really, really. One reason is that I want to write an optimizing compiler for a <a class="zem_slink" href="http://en.wikipedia.org/wiki/Duck_typing" rel="wikipedia" title="Duck typing">duck-typed</a>&nbsp;<a class="zem_slink" href="http://en.wikipedia.org/wiki/Functional_programming" rel="wikipedia" title="Functional programming">functional language</a>, that can still analyze types statically. But, perhaps, the more important reason is that I think that code is a great way to communicate with an AI. You can describe games, puzzles, theorems, goals, etc, very succinctly in code.<br /><br />Programmatically understanding code is hard, though. The <a class="zem_slink" href="http://en.wikipedia.org/wiki/Halting_problem" rel="wikipedia" title="Halting problem">halting problem</a> and <a class="zem_slink" href="http://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems" rel="wikipedia" title="Gödel's incompleteness theorems">Gödel's incompleteness theorem</a> show that it is not even possible in theory to understand and analyze everything.<br /><br />Having obsessed over this for a long time, I finally have what I believe is a good approach to the problem. I don't have even a line of code written yet, because I first wanted to flesh out the details and write this blog post to get everything clear in my head.<br /><br />But first things first.<br /><br /><span class="Apple-style-span" style="font-size: large;">The language</span><br /><br />First we need a language to analyze. I have chosen a functional subset of <a class="zem_slink" href="http://en.wikipedia.org/wiki/Scheme_%28programming_language%29" rel="wikipedia" title="Scheme (programming language)">Scheme</a> (a simple <a class="zem_slink" href="http://en.wikipedia.org/wiki/Lisp_%28programming_language%29" rel="wikipedia" title="Lisp (programming language)">Lisp</a> dialect). Scheme is good because it uses the Lisp syntax, which makes it easy to parse and understand what is going on. I actually prefer reading and writing code in a language with more syntax, because I believe that it helps the eye, but here simplicity is more important. I will use only a functional subset of Scheme, because it is easier to analyze. I suspect imperative code is not that much harder, but there is no reason to make this undertaking more complex than it already is. Scheme also has&nbsp;<a href="http://en.wikipedia.org/wiki/Continuations">first-class continuations</a>, which are way cool and useful, but trying to make sense of them would also complicate analysis, so let's skip them for now. Ah yes, macros are a very important part of Lisp and probably not that complicated to analyze, but we don't need them yet, so let's skip those too. Also, for now, we skip eval. Come to think of it, maybe it is not even a subset of Scheme anymore. Maybe it is more of a new minimalistic but less useful Lisp dialect.<br /><br />We have four basic data types: symbols, booleans, unbounded integers, functions/lambdas and lists (well, technically pairs/conses). Functions are really a pair of lists, where the first list is an argument list of symbols and the other is the body. I have not yet decided if functions should be regarded as just lists &nbsp;or if they should be a special data type. If they are just lists, I must allow to construct new lists and call eval on them. For the coming discussion it does not matter which way is chosen.<br /><br />We have three functions that operate on booleans: <i>or, not, if</i>. If is the only branching function. "and" can be defined in terms of "or" and "not". (and a b) &amp;lt;=&amp;gt; (not (or (not a) (not b)))<br /><br />On integers we have <i>&amp;gt;, ++(increment), --(decrement)</i>. Plus, minus, negation, multiplication, &amp;lt; and a few others can be (sometimes recursively) defined in terms of these.<br /><br />On lists we have <i>quote, cons, car, cdr</i>. Others can be defined in terms of these. cons takes two arguments and makes a pair. Lists are actually nested pairs, so cons simply takes a list and an element and &nbsp;returns a new list, where the element is in front of the old list. A functional push_front. car returns the front element (the first element in the pair) and cdr returns the rest of the list (the second element in the pair). quote is used to express that a list should not be evaluated, but just treated as data. Normally you use the syntactic sugar '(1 2 3) instead of (quote (1 2 3)). If we did not use the quote, the list would be executed by trying to use 1 as a function with arguments 2 and 3.<br /><br />Furthermore we have <i>let, lambda</i> and <i>== (recursive equal)</i>.<br />"lambda" just returns an anonymous function. <span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">(lambda (a b) (+ a b))</span> returns a function that takes two arguments and returns the sum. By mixing this with let, we can make named functions.<br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">(let ((a 5) (b (lambda (x) (+ x 3)))) (b a))</span> sets a to 5 and b to a function in the second expression and then evaluates it. This will return 8. The equivalent of let in Scheme would be letrec, since the function can access its own name and call itself.<br /><br />That makes 13 functions (14 with eval). I may have to add some fundamental querying functions, like <i>int?</i> that returns true if the argument is an integer, but I will try to avoid it. Don't worry if you are not sure exactly how this is language works, it will become clear enough in the examples. Since there are no looping constructs, all iteration is handled by recursion.<br /><br />It is important to have as few built-in functions as possible, as each built-in needs to know how to respond to Analyzer requests (more about that later).<br /><br />We could have even fewer built-ins if we threw out booleans and defined them in terms of integers, like C. Also we could throw out integers and define them in terms of list sizes (++ would cons an empty list onto the target list, and -- would be cdr). Even lists themselves can be defined in terms of functions and suddenly we have <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>. When you remove types you are met with two problems, 1) it makes it harder to spot bugs in your code since adding a list to a bool would suddenly be ok (this is not a primary concern when designing an Analyzer, as we can assume that the question functions are correct), and 2) it makes it harder to reason about for the Analyzer. The Analyzer would have to derive theorems about, for example, multiplication from simple recursive definitions starting with lists.<br /><br /><span class="Apple-style-span" style="font-size: large;">Problem statement</span><br /><br />The Analyzer (an, as yet, undefined, possibly magical system) will be presented with a "question function" and asked to find a set of arguments that makes it return true (as opposed to returning something else, throwing an exception or running forever), or to show that this is impossible. This will always be the object of the analysis. Note that the arguments may be functions, so that the object of the analysis could be to come up with a function that does something specific. Yes, those problems are hard. All problems which are not open-ended ("find the best", "optimize", etc) can be presented thus. You will notice that this allows for exactly the sort of questions which the halting problem shows are unanswerable in general.<br /><br /><span class="Apple-style-span" style="font-size: large;">Examples</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">1.</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">(lambda (n)</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp; (and (&lt; n 1000000000) (&gt; n 900000000)))</span><br /><br />This should be easy enough. The Analyzer could for example output n = 900 000 001, which would cause the question function to return true, since n is over 900 000 000 and below 1 000 000 000.<br /><br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">2.</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">(lambda (x y)</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp; (let ((cross (lambda (x y n)</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-tab-span" style="white-space: pre;">  </span> &nbsp; (if (&gt;= x y) (== n 0)</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-tab-span" style="white-space: pre;">  </span> &nbsp; &nbsp; &nbsp; (cross (+ x 10) (+ y 7) (- n 1))))))</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; (cross x y 5)))</span><br /><br /><br />Meaning: construct a function with two arguments, x and y. Construct an inner function with three arguments, x, y and n and bind it to the name "cross". The inner function checks if x &gt;= y and, if so, returns true if n is 0. Otherwise it calls itself with 10 added to x, 7 added to y and n decreased. It is clear that sooner or later x will pass y. Finally the body of the let expression calls cross with n set to 5.<br /><br />What would be proper arguments for x and y to make this function return true? n counts how many times the function has recursed and x increases by 3 more than y each recursion. Thus, any x and y where x &nbsp;+ 4*3 &lt; y and x + 5*3 &gt;= y will do. For example x = 0 and y = 14.<br /><br />My Analyzer should be able to understand that.<br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">3.</span><br />In my third example I was going to paste a functional implementation of a simulator for <a href="http://en.wikipedia.org/wiki/Towers_of_hanoi">Towers of Hanoi</a>, where you give the function a list of moves, it performs them, and finally returns true if all the moves are legal and the discs are moved to the target location. However, the code got quite large and is written in regular Scheme, so I could test it more easily. To avoid scaring away any reader who actually got this far, I will not show this 20 line behemoth, as it is very much beside the point. Instead, imagine that you saw it and that you now nod and think to yourself "Aha.. this is how you would present a more complex puzzle to the Analyzer".<br /><br />If I wanted the Analyzer to give me the shortest possible answer to the puzzle, I would, beside the puzzle, define a simple brute force function that found the shortest possible answer (even though for large towers it would not finish in the lifetime of our universe) and make sure the question function did not return true unless the solution in the argument is as short as the one the brute forcer found. I am not telling anyone to run the function I have just created. I am just asking the Analyzer to tell me what arguments would make it return true if it actually were executed. As long as it proves to itself that the brute forcer cannot find anything shorter, it does not actually have to run it.<br /><br />This would be extremely challenging to solve without very specialized knowledge. I hope that my approach will one day be able to solve such puzzles using only general purpose algorithms. I have a reasonably detailed plan for how to get there.<br /><br /><span class="Apple-style-span" style="font-family: inherit;">Problems where the Analyzer would need to submit a function as one of the arguments are of course even more challenging and, in general, quite unsolvable. I have only a vague idea of how this will work.</span><br /><br /><span class="Apple-style-span" style="font-size: large;">The Trees</span><br /><the code="" tree=""></the><br /><the and="" branching="" knowledge="" tree=""></the><br /><br /><br /><span class="Apple-style-span" style="font-size: large;">The Analysis</span><br /><br /><br /><span class="Apple-style-span" style="font-size: large;">Recursion</span><br /><br /><br /><span class="Apple-style-span" style="font-size: large;">Summing up</span><br /><the proofs=""></the><br /><br /><div class="zemanta-pixie" style="height: 15px; margin-top: 10px;"><a class="zemanta-pixie-a" href="http://www.zemanta.com/" title="Enhanced by Zemanta"><img alt="Enhanced by Zemanta" class="zemanta-pixie-img" src="http://img.zemanta.com/zemified_e.png?x-id=33521d06-10b5-48ce-8c2c-5f768f15e312" style="border: none; float: right;" /></a></div></div>
